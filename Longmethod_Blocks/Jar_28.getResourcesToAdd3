ArchiveState#getResourcesToAdd#(#ResourceCollection#[#]#rcs#,#File#zipFile#,#boolean#needsUpdate#)#throws#BuildException#{##if#(#skipWriting#)#{##// this pass is only there to construct the merged##// manifest this means we claim an update was needed and##// only include the manifests, skipping any uptodate##// checks here defering them for the second run##return#new#ArchiveState#(#true#,#grabManifests#(#rcs#)#)#;#}##// need to handle manifest as a special check##if#(#zipFile#.#exists#(#)#)#{##// if it doesn't exist, it will get created anyway, don't##// bother with any up-to-date checks.#try#{#originalManifest#=#getManifestFromJar#(#zipFile#)#;##if#(#originalManifest#==#null#)#{#log#(#"Updating jar since the current jar has"#+#" no manifest"#,#Project#.#MSG_VERBOSE#)#;#needsUpdate#=#true#;#}#else#{#Manifest#mf#=#createManifest#(#)#;##if#(#!#mf#.#equals#(#originalManifest#)#)#{#log#(#"Updating jar since jar manifest has"#+#" changed"#,#Project#.#MSG_VERBOSE#)#;#needsUpdate#=#true#;#}#}#}##catch#(#Throwable#t#)#{#log#(#"error while reading original manifest in file: "#+#zipFile#.#toString#(#)#+#" due to "#+#t#.#getMessage#(#)#,#Project#.#MSG_WARN#)#;#needsUpdate#=#true#;#}#}#else#{##// no existing archive#needsUpdate#=#true#;#}##createEmpty#=#needsUpdate#;##if#(#!#needsUpdate#&&#index#)#{#try#{#needsUpdate#=#!#jarHasIndex#(#zipFile#)#;#}##catch#(#IOException#e#)#{##//if we couldn't read it, we might as well recreate it?#needsUpdate#=#true#;#}#}##return#super#.#getResourcesToAdd#(#rcs#,#zipFile#,#needsUpdate#)#;#}