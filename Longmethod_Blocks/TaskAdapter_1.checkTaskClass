void#checkTaskClass#(#final#Class#taskClass#,#final#Project#project#)#{##if#(#!#Dispatchable#.#class#.#isAssignableFrom#(#taskClass#)#)#{##// don't have to check for interface, since then##// taskClass would be abstract too.#try#{#final#Method#executeM#=#taskClass#.#getMethod#(#"execute"#,#(#Class#[#]#)#null#)#;##// don't have to check for public, since##// getMethod finds public method only.##// don't have to check for abstract, since then##// taskClass would be abstract too.##if#(#!#Void#.#TYPE#.#equals#(#executeM#.#getReturnType#(#)#)#)#{#final#String#message#=#"return type of execute() should be "#+#"void but was \""#+#executeM#.#getReturnType#(#)#+#"\" in "#+#taskClass#;#project#.#log#(#message#,#Project#.#MSG_WARN#)#;#}#}##catch#(#NoSuchMethodException#e#)#{#final#String#message#=#"No public execute() in "#+#taskClass#;#project#.#log#(#message#,#Project#.#MSG_ERR#)#;#throw#new#BuildException#(#message#)#;#}##catch#(#LinkageError#e#)#{#String#message#=#"Could not load "#+#taskClass#+#": "#+#e#;#project#.#log#(#message#,#Project#.#MSG_ERR#)#;#throw#new#BuildException#(#message#,#e#)#;#}#}#}