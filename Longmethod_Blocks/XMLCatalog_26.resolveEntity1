InputSource#resolveEntity#(#String#publicId#,#String#systemId#)#{#InputSource#result#=#null#;#processExternalCatalogs#(#)#;#ResourceLocation#matchingEntry#=#findMatchingEntry#(#publicId#)#;##if#(#matchingEntry#!=#null#)#{#log#(#"Matching catalog entry found for publicId: '"#+#matchingEntry#.#getPublicId#(#)#+#"' location: '"#+#matchingEntry#.#getLocation#(#)#+#"'"#,#Project#.#MSG_DEBUG#)#;#result#=#filesystemLookup#(#matchingEntry#)#;##if#(#result#==#null#)#{#result#=#classpathLookup#(#matchingEntry#)#;#}##if#(#result#==#null#)#{#try#{#result#=#(#InputSource#)#resolveEntity#.#invoke#(#resolverImpl#,#new#Object#[#]#{#publicId#,#systemId#}#)#;#}##catch#(#Exception#ex#)#{#throw#new#BuildException#(#ex#)#;#}#}#}#else#{##//##// We didn't match a ResourceLocation, but since we##// only support PUBLIC and URI entry types internally,##// it is still possible that there is another entry in##// an external catalog that will match.  We call##// Apache resolver's resolveEntity method to cover##// this possibility.##//#try#{#result#=#(#InputSource#)#resolveEntity#.#invoke#(#resolverImpl#,#new#Object#[#]#{#publicId#,#systemId#}#)#;#}##catch#(#Exception#ex#)#{#throw#new#BuildException#(#ex#)#;#}#}##return#result#;#}