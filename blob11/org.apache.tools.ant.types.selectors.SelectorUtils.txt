SelectorUtils#getInstance#(#)#{#return#instance#;#}##boolean#matchPatternStart#(#String#pattern#,#String#str#)#{#return#matchPatternStart#(#pattern#,#str#,#true#)#;#}##boolean#matchPatternStart#(#String#pattern#,#String#str#,#boolean#isCaseSensitive#)#{#// When str starts with a File.separator, pattern has to start with a#// File.separator.#// When pattern starts with a File.separator, str has to start with a#// File.separator.#if#(#str#.#startsWith#(#File#.#separator#)#!=#pattern#.#startsWith#(#File#.#separator#)#)#{#return#false#;#}#String#[#]#patDirs#=#tokenizePathAsArray#(#pattern#)#;#String#[#]#strDirs#=#tokenizePathAsArray#(#str#)#;#return#matchPatternStart#(#patDirs#,#strDirs#,#isCaseSensitive#)#;#}##boolean#matchPatternStart#(#String#[#]#patDirs#,#String#[#]#strDirs#,#boolean#isCaseSensitive#)#{#int#patIdxStart#=#0#;#int#patIdxEnd#=#patDirs#.#length#-#1#;#int#strIdxStart#=#0#;#int#strIdxEnd#=#strDirs#.#length#-#1#;#// up to first '**'#while#(#patIdxStart#<=#patIdxEnd#&&#strIdxStart#<=#strIdxEnd#)#{#String#patDir#=#patDirs#[#patIdxStart#]#;#if#(#patDir#.#equals#(#DEEP_TREE_MATCH#)#)#{#break#;#}#if#(#!#match#(#patDir#,#strDirs#[#strIdxStart#]#,#isCaseSensitive#)#)#{#return#false#;#}#patIdxStart#++#;#strIdxStart#++#;#}#// CheckStyle:SimplifyBooleanReturnCheck OFF#// Check turned off as the code needs the comments for the various#// code paths.#if#(#strIdxStart#>#strIdxEnd#)#{#// String is exhausted#return#true#;#}#else#if#(#patIdxStart#>#patIdxEnd#)#{#// String not exhausted, but pattern is. Failure.#return#false#;#}#else#{#// pattern now holds ** while string is not exhausted#// this will generate false positives but we can live with that.#return#true#;#}#}##boolean#matchPath#(#String#pattern#,#String#str#)#{#String#[#]#patDirs#=#tokenizePathAsArray#(#pattern#)#;#return#matchPath#(#patDirs#,#tokenizePathAsArray#(#str#)#,#true#)#;#}##boolean#matchPath#(#String#pattern#,#String#str#,#boolean#isCaseSensitive#)#{#String#[#]#patDirs#=#tokenizePathAsArray#(#pattern#)#;#return#matchPath#(#patDirs#,#tokenizePathAsArray#(#str#)#,#isCaseSensitive#)#;#}##boolean#matchPath#(#String#[#]#tokenizedPattern#,#String#[#]#strDirs#,#boolean#isCaseSensitive#)#{#int#patIdxStart#=#0#;#int#patIdxEnd#=#tokenizedPattern#.#length#-#1#;#int#strIdxStart#=#0#;#int#strIdxEnd#=#strDirs#.#length#-#1#;#// up to first '**'#while#(#patIdxStart#<=#patIdxEnd#&&#strIdxStart#<=#strIdxEnd#)#{#String#patDir#=#tokenizedPattern#[#patIdxStart#]#;#if#(#patDir#.#equals#(#DEEP_TREE_MATCH#)#)#{#break#;#}#if#(#!#match#(#patDir#,#strDirs#[#strIdxStart#]#,#isCaseSensitive#)#)#{#return#false#;#}#patIdxStart#++#;#strIdxStart#++#;#}#if#(#strIdxStart#>#strIdxEnd#)#{#// String is exhausted#for#(#int#i#=#patIdxStart#;#i#<=#patIdxEnd#;#i#++#)#{#if#(#!#tokenizedPattern#[#i#]#.#equals#(#DEEP_TREE_MATCH#)#)#{#return#false#;#}#}#return#true#;#}#else#{#if#(#patIdxStart#>#patIdxEnd#)#{#// String not exhausted, but pattern is. Failure.#return#false#;#}#}#// up to last '**'#while#(#patIdxStart#<=#patIdxEnd#&&#strIdxStart#<=#strIdxEnd#)#{#String#patDir#=#tokenizedPattern#[#patIdxEnd#]#;#if#(#patDir#.#equals#(#DEEP_TREE_MATCH#)#)#{#break#;#}#if#(#!#match#(#patDir#,#strDirs#[#strIdxEnd#]#,#isCaseSensitive#)#)#{#return#false#;#}#patIdxEnd#--#;#strIdxEnd#--#;#}#if#(#strIdxStart#>#strIdxEnd#)#{#// String is exhausted#for#(#int#i#=#patIdxStart#;#i#<=#patIdxEnd#;#i#++#)#{#if#(#!#tokenizedPattern#[#i#]#.#equals#(#DEEP_TREE_MATCH#)#)#{#return#false#;#}#}#return#true#;#}#while#(#patIdxStart#!=#patIdxEnd#&&#strIdxStart#<=#strIdxEnd#)#{#int#patIdxTmp#=#-#1#;#for#(#int#i#=#patIdxStart#+#1#;#i#<=#patIdxEnd#;#i#++#)#{#if#(#tokenizedPattern#[#i#]#.#equals#(#DEEP_TREE_MATCH#)#)#{#patIdxTmp#=#i#;#break#;#}#}#if#(#patIdxTmp#==#patIdxStart#+#1#)#{#// '**/**' situation, so skip one#patIdxStart#++#;#continue#;#}#// Find the pattern between padIdxStart & padIdxTmp in str between#// strIdxStart & strIdxEnd#int#patLength#=#(#patIdxTmp#-#patIdxStart#-#1#)#;#int#strLength#=#(#strIdxEnd#-#strIdxStart#+#1#)#;#int#foundIdx#=#-#1#;#strLoop#:#for#(#int#i#=#0#;#i#<=#strLength#-#patLength#;#i#++#)#{#for#(#int#j#=#0#;#j#<#patLength#;#j#++#)#{#String#subPat#=#tokenizedPattern#[#patIdxStart#+#j#+#1#]#;#String#subStr#=#strDirs#[#strIdxStart#+#i#+#j#]#;#if#(#!#match#(#subPat#,#subStr#,#isCaseSensitive#)#)#{#continue#strLoop#;#}#}#foundIdx#=#strIdxStart#+#i#;#break#;#}#if#(#foundIdx#==#-#1#)#{#return#false#;#}#patIdxStart#=#patIdxTmp#;#strIdxStart#=#foundIdx#+#patLength#;#}#for#(#int#i#=#patIdxStart#;#i#<=#patIdxEnd#;#i#++#)#{#if#(#!#tokenizedPattern#[#i#]#.#equals#(#DEEP_TREE_MATCH#)#)#{#return#false#;#}#}#return#true#;#}##boolean#match#(#String#pattern#,#String#str#)#{#return#match#(#pattern#,#str#,#true#)#;#}##boolean#match#(#String#pattern#,#String#str#,#boolean#caseSensitive#)#{#char#[#]#patArr#=#pattern#.#toCharArray#(#)#;#char#[#]#strArr#=#str#.#toCharArray#(#)#;#int#patIdxStart#=#0#;#int#patIdxEnd#=#patArr#.#length#-#1#;#int#strIdxStart#=#0#;#int#strIdxEnd#=#strArr#.#length#-#1#;#char#ch#;#boolean#containsStar#=#false#;#for#(#int#i#=#0#;#i#<#patArr#.#length#;#i#++#)#{#if#(#patArr#[#i#]#==#'*'#)#{#containsStar#=#true#;#break#;#}#}#if#(#!#containsStar#)#{#// No '*'s, so we make a shortcut#if#(#patIdxEnd#!=#strIdxEnd#)#{#return#false#;#// Pattern and string do not have the same size#}#for#(#int#i#=#0#;#i#<=#patIdxEnd#;#i#++#)#{#ch#=#patArr#[#i#]#;#if#(#ch#!=#'?'#)#{#if#(#different#(#caseSensitive#,#ch#,#strArr#[#i#]#)#)#{#return#false#;#// Character mismatch#}#}#}#return#true#;#// String matches against pattern#}#if#(#patIdxEnd#==#0#)#{#return#true#;#// Pattern contains only '*', which matches anything#}#// Process characters before first star#while#(#true#)#{#ch#=#patArr#[#patIdxStart#]#;#if#(#ch#==#'*'#||#strIdxStart#>#strIdxEnd#)#{#break#;#}#if#(#ch#!=#'?'#)#{#if#(#different#(#caseSensitive#,#ch#,#strArr#[#strIdxStart#]#)#)#{#return#false#;#// Character mismatch#}#}#patIdxStart#++#;#strIdxStart#++#;#}#if#(#strIdxStart#>#strIdxEnd#)#{#// All characters in the string are used. Check if only '*'s are#// left in the pattern. If so, we succeeded. Otherwise failure.#return#allStars#(#patArr#,#patIdxStart#,#patIdxEnd#)#;#}#// Process characters after last star#while#(#true#)#{#ch#=#patArr#[#patIdxEnd#]#;#if#(#ch#==#'*'#||#strIdxStart#>#strIdxEnd#)#{#break#;#}#if#(#ch#!=#'?'#)#{#if#(#different#(#caseSensitive#,#ch#,#strArr#[#strIdxEnd#]#)#)#{#return#false#;#// Character mismatch#}#}#patIdxEnd#--#;#strIdxEnd#--#;#}#if#(#strIdxStart#>#strIdxEnd#)#{#// All characters in the string are used. Check if only '*'s are#// left in the pattern. If so, we succeeded. Otherwise failure.#return#allStars#(#patArr#,#patIdxStart#,#patIdxEnd#)#;#}#// process pattern between stars. padIdxStart and patIdxEnd point#// always to a '*'.#while#(#patIdxStart#!=#patIdxEnd#&&#strIdxStart#<=#strIdxEnd#)#{#int#patIdxTmp#=#-#1#;#for#(#int#i#=#patIdxStart#+#1#;#i#<=#patIdxEnd#;#i#++#)#{#if#(#patArr#[#i#]#==#'*'#)#{#patIdxTmp#=#i#;#break#;#}#}#if#(#patIdxTmp#==#patIdxStart#+#1#)#{#// Two stars next to each other, skip the first one.#patIdxStart#++#;#continue#;#}#// Find the pattern between padIdxStart & padIdxTmp in str between#// strIdxStart & strIdxEnd#int#patLength#=#(#patIdxTmp#-#patIdxStart#-#1#)#;#int#strLength#=#(#strIdxEnd#-#strIdxStart#+#1#)#;#int#foundIdx#=#-#1#;#strLoop#:#for#(#int#i#=#0#;#i#<=#strLength#-#patLength#;#i#++#)#{#for#(#int#j#=#0#;#j#<#patLength#;#j#++#)#{#ch#=#patArr#[#patIdxStart#+#j#+#1#]#;#if#(#ch#!=#'?'#)#{#if#(#different#(#caseSensitive#,#ch#,#strArr#[#strIdxStart#+#i#+#j#]#)#)#{#continue#strLoop#;#}#}#}#foundIdx#=#strIdxStart#+#i#;#break#;#}#if#(#foundIdx#==#-#1#)#{#return#false#;#}#patIdxStart#=#patIdxTmp#;#strIdxStart#=#foundIdx#+#patLength#;#}#// All characters in the string are used. Check if only '*'s are left#// in the pattern. If so, we succeeded. Otherwise failure.#return#allStars#(#patArr#,#patIdxStart#,#patIdxEnd#)#;#}##boolean#allStars#(#char#[#]#chars#,#int#start#,#int#end#)#{#for#(#int#i#=#start#;#i#<=#end#;#++#i#)#{#if#(#chars#[#i#]#!=#'*'#)#{#return#false#;#}#}#return#true#;#}##boolean#different#(#boolean#caseSensitive#,#char#ch#,#char#other#)#{#return#caseSensitive#?#ch#!=#other#:#Character#.#toUpperCase#(#ch#)#!=#Character#.#toUpperCase#(#other#)#;#}##Vector#tokenizePath#(#String#path#)#{#return#tokenizePath#(#path#,#File#.#separator#)#;#}##Vector#tokenizePath#(#String#path#,#String#separator#)#{#Vector#ret#=#new#Vector#(#)#;#if#(#FileUtils#.#isAbsolutePath#(#path#)#)#{#String#[#]#s#=#FILE_UTILS#.#dissect#(#path#)#;#ret#.#add#(#s#[#0#]#)#;#path#=#s#[#1#]#;#}#StringTokenizer#st#=#new#StringTokenizer#(#path#,#separator#)#;#while#(#st#.#hasMoreTokens#(#)#)#{#ret#.#addElement#(#st#.#nextToken#(#)#)#;#}#return#ret#;#}##String#[#]#tokenizePathAsArray#(#String#path#)#{#String#root#=#null#;#if#(#FileUtils#.#isAbsolutePath#(#path#)#)#{#String#[#]#s#=#FILE_UTILS#.#dissect#(#path#)#;#root#=#s#[#0#]#;#path#=#s#[#1#]#;#}#char#sep#=#File#.#separatorChar#;#int#start#=#0#;#int#len#=#path#.#length#(#)#;#int#count#=#0#;#for#(#int#pos#=#0#;#pos#<#len#;#pos#++#)#{#if#(#path#.#charAt#(#pos#)#==#sep#)#{#if#(#pos#!=#start#)#{#count#++#;#}#start#=#pos#+#1#;#}#}#if#(#len#!=#start#)#{#count#++#;#}#String#[#]#l#=#new#String#[#count#+#(#(#root#==#null#)#?#0#:#1#)#]#;#if#(#root#!=#null#)#{#l#[#0#]#=#root#;#count#=#1#;#}#else#{#count#=#0#;#}#start#=#0#;#for#(#int#pos#=#0#;#pos#<#len#;#pos#++#)#{#if#(#path#.#charAt#(#pos#)#==#sep#)#{#if#(#pos#!=#start#)#{#String#tok#=#path#.#substring#(#start#,#pos#)#;#l#[#count#++#]#=#tok#;#}#start#=#pos#+#1#;#}#}#if#(#len#!=#start#)#{#String#tok#=#path#.#substring#(#start#)#;#l#[#count#/*++*/#]#=#tok#;#}#return#l#;#}##boolean#isOutOfDate#(#File#src#,#File#target#,#int#granularity#)#{#if#(#!#src#.#exists#(#)#)#{#return#false#;#}#if#(#!#target#.#exists#(#)#)#{#return#true#;#}#if#(#(#src#.#lastModified#(#)#-#granularity#)#>#target#.#lastModified#(#)#)#{#return#true#;#}#return#false#;#}##boolean#isOutOfDate#(#Resource#src#,#Resource#target#,#int#granularity#)#{#return#isOutOfDate#(#src#,#target#,#(#long#)#granularity#)#;#}##boolean#isOutOfDate#(#Resource#src#,#Resource#target#,#long#granularity#)#{#long#sourceLastModified#=#src#.#getLastModified#(#)#;#long#targetLastModified#=#target#.#getLastModified#(#)#;#return#src#.#isExists#(#)#&&#(#sourceLastModified#==#Resource#.#UNKNOWN_DATETIME#||#targetLastModified#==#Resource#.#UNKNOWN_DATETIME#||#(#sourceLastModified#-#granularity#)#>#targetLastModified#)#;#}##String#removeWhitespace#(#String#input#)#{#StringBuffer#result#=#new#StringBuffer#(#)#;#if#(#input#!=#null#)#{#StringTokenizer#st#=#new#StringTokenizer#(#input#)#;#while#(#st#.#hasMoreTokens#(#)#)#{#result#.#append#(#st#.#nextToken#(#)#)#;#}#}#return#result#.#toString#(#)#;#}##boolean#hasWildcards#(#String#input#)#{#return#(#input#.#indexOf#(#'*'#)#!=#-#1#||#input#.#indexOf#(#'?'#)#!=#-#1#)#;#}##String#rtrimWildcardTokens#(#String#input#)#{#return#new#TokenizedPattern#(#input#)#.#rtrimWildcardTokens#(#)#.#toString#(#)#;#}##