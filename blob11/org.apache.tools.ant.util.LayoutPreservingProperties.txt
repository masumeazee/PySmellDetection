boolean#isRemoveComments#(#)#{#return#removeComments#;#}##void#setRemoveComments#(#boolean#val#)#{#removeComments#=#val#;#}##void#load#(#InputStream#inStream#)#throws#IOException#{#String#s#=#readLines#(#inStream#)#;#byte#[#]#ba#=#s#.#getBytes#(#"ISO-8859-1"#)#;#ByteArrayInputStream#bais#=#new#ByteArrayInputStream#(#ba#)#;#super#.#load#(#bais#)#;#}##Object#put#(#Object#key#,#Object#value#)#throws#NullPointerException#{#Object#obj#=#super#.#put#(#key#,#value#)#;#// the above call will have failed if key or value are null#innerSetProperty#(#key#.#toString#(#)#,#value#.#toString#(#)#)#;#return#obj#;#}##Object#setProperty#(#String#key#,#String#value#)#throws#NullPointerException#{#Object#obj#=#super#.#setProperty#(#key#,#value#)#;#// the above call will have failed if key or value are null#innerSetProperty#(#key#,#value#)#;#return#obj#;#}##void#innerSetProperty#(#String#key#,#String#value#)#{#value#=#escapeValue#(#value#)#;#if#(#keyedPairLines#.#containsKey#(#key#)#)#{#Integer#i#=#(#Integer#)#keyedPairLines#.#get#(#key#)#;#Pair#p#=#(#Pair#)#logicalLines#.#get#(#i#.#intValue#(#)#)#;#p#.#setValue#(#value#)#;#}#else#{#key#=#escapeName#(#key#)#;#Pair#p#=#new#Pair#(#key#,#value#)#;#p#.#setNew#(#true#)#;#keyedPairLines#.#put#(#key#,#new#Integer#(#logicalLines#.#size#(#)#)#)#;#logicalLines#.#add#(#p#)#;#}#}##void#clear#(#)#{#super#.#clear#(#)#;#keyedPairLines#.#clear#(#)#;#logicalLines#.#clear#(#)#;#}##Object#remove#(#Object#key#)#{#Object#obj#=#super#.#remove#(#key#)#;#Integer#i#=#(#Integer#)#keyedPairLines#.#remove#(#key#)#;#if#(#null#!=#i#)#{#if#(#removeComments#)#{#removeCommentsEndingAt#(#i#.#intValue#(#)#)#;#}#logicalLines#.#set#(#i#.#intValue#(#)#,#null#)#;#}#return#obj#;#}##Object#clone#(#)#{#LayoutPreservingProperties#dolly#=#(#LayoutPreservingProperties#)#super#.#clone#(#)#;#dolly#.#keyedPairLines#=#(#HashMap#)#this#.#keyedPairLines#.#clone#(#)#;#dolly#.#logicalLines#=#(#ArrayList#)#this#.#logicalLines#.#clone#(#)#;#for#(#int#j#=#0#;#j#<#dolly#.#logicalLines#.#size#(#)#;#j#++#)#{#LogicalLine#line#=#(#LogicalLine#)#dolly#.#logicalLines#.#get#(#j#)#;#if#(#line#instanceof#Pair#)#{#Pair#p#=#(#Pair#)#line#;#dolly#.#logicalLines#.#set#(#j#,#p#.#clone#(#)#)#;#}#// no reason to clone other lines are they are immutable#}#return#dolly#;#}##void#listLines#(#PrintStream#out#)#{#out#.#println#(#"-- logical lines --"#)#;#Iterator#i#=#logicalLines#.#iterator#(#)#;#while#(#i#.#hasNext#(#)#)#{#LogicalLine#line#=#(#LogicalLine#)#i#.#next#(#)#;#if#(#line#instanceof#Blank#)#{#out#.#println#(#"blank:   \""#+#line#+#"\""#)#;#}#else#if#(#line#instanceof#Comment#)#{#out#.#println#(#"comment: \""#+#line#+#"\""#)#;#}#else#if#(#line#instanceof#Pair#)#{#out#.#println#(#"pair:    \""#+#line#+#"\""#)#;#}#}#}##void#saveAs#(#File#dest#)#throws#IOException#{#FileOutputStream#fos#=#new#FileOutputStream#(#dest#)#;#store#(#fos#,#null#)#;#fos#.#close#(#)#;#}##void#store#(#OutputStream#out#,#String#header#)#throws#IOException#{#OutputStreamWriter#osw#=#new#OutputStreamWriter#(#out#,#"ISO-8859-1"#)#;#int#skipLines#=#0#;#int#totalLines#=#logicalLines#.#size#(#)#;#if#(#header#!=#null#)#{#osw#.#write#(#"#"#+#header#+#LS#)#;#if#(#totalLines#>#0#&&#logicalLines#.#get#(#0#)#instanceof#Comment#&&#header#.#equals#(#logicalLines#.#get#(#0#)#.#toString#(#)#.#substring#(#1#)#)#)#{#skipLines#=#1#;#}#}#// we may be updatiung a file written by this class, replace#// the date comment instead of adding a new one and preserving#// the one written last time#if#(#totalLines#>#skipLines#&&#logicalLines#.#get#(#skipLines#)#instanceof#Comment#)#{#try#{#DateUtils#.#parseDateFromHeader#(#logicalLines#.#get#(#skipLines#)#.#toString#(#)#.#substring#(#1#)#)#;#skipLines#++#;#}#catch#(#java#.#text#.#ParseException#pe#)#{#// not an existing date comment#}#}#osw#.#write#(#"#"#+#DateUtils#.#getDateForHeader#(#)#+#LS#)#;#boolean#writtenSep#=#false#;#for#(#Iterator#i#=#logicalLines#.#subList#(#skipLines#,#totalLines#)#.#iterator#(#)#;#i#.#hasNext#(#)#;#)#{#LogicalLine#line#=#(#LogicalLine#)#i#.#next#(#)#;#if#(#line#instanceof#Pair#)#{#if#(#(#(#Pair#)#line#)#.#isNew#(#)#)#{#if#(#!#writtenSep#)#{#osw#.#write#(#LS#)#;#writtenSep#=#true#;#}#}#osw#.#write#(#line#.#toString#(#)#+#LS#)#;#}#else#if#(#line#!=#null#)#{#osw#.#write#(#line#.#toString#(#)#+#LS#)#;#}#}#osw#.#close#(#)#;#}##String#readLines#(#InputStream#is#)#throws#IOException#{#InputStreamReader#isr#=#new#InputStreamReader#(#is#,#"ISO-8859-1"#)#;#BufferedReader#br#=#new#BufferedReader#(#isr#)#;#if#(#logicalLines#.#size#(#)#>#0#)#{#// we add a blank line for spacing#logicalLines#.#add#(#new#Blank#(#)#)#;#}#String#s#=#br#.#readLine#(#)#;#boolean#continuation#=#false#;#boolean#comment#=#false#;#StringBuffer#fileBuffer#=#new#StringBuffer#(#)#;#StringBuffer#logicalLineBuffer#=#new#StringBuffer#(#)#;#while#(#s#!=#null#)#{#fileBuffer#.#append#(#s#)#.#append#(#LS#)#;#if#(#continuation#)#{#// put in the line feed that was removed#s#=#"\n"#+#s#;#}#else#{#// could be a comment, if first non-whitespace is a # or !#comment#=#s#.#matches#(#"^( |\t|\f)*(#|!).*"#)#;#}#// continuation if not a comment and the line ends is an#// odd number of backslashes#if#(#!#comment#)#{#continuation#=#requiresContinuation#(#s#)#;#}#logicalLineBuffer#.#append#(#s#)#;#if#(#!#continuation#)#{#LogicalLine#line#=#null#;#if#(#comment#)#{#line#=#new#Comment#(#logicalLineBuffer#.#toString#(#)#)#;#}#else#if#(#logicalLineBuffer#.#toString#(#)#.#trim#(#)#.#length#(#)#==#0#)#{#line#=#new#Blank#(#)#;#}#else#{#line#=#new#Pair#(#logicalLineBuffer#.#toString#(#)#)#;#String#key#=#unescape#(#(#(#Pair#)#line#)#.#getName#(#)#)#;#if#(#keyedPairLines#.#containsKey#(#key#)#)#{#// this key is already present, so we remove it and add#// the new one#remove#(#key#)#;#}#keyedPairLines#.#put#(#key#,#new#Integer#(#logicalLines#.#size#(#)#)#)#;#}#logicalLines#.#add#(#line#)#;#logicalLineBuffer#.#setLength#(#0#)#;#}#s#=#br#.#readLine#(#)#;#}#return#fileBuffer#.#toString#(#)#;#}##boolean#requiresContinuation#(#String#s#)#{#char#[#]#ca#=#s#.#toCharArray#(#)#;#int#i#=#ca#.#length#-#1#;#while#(#i#>#0#&&#ca#[#i#]#==#'\\'#)#{#i#--#;#}#// trailing backslashes#int#tb#=#ca#.#length#-#i#-#1#;#return#tb#%#2#==#1#;#}##String#unescape#(#String#s#)#{#/*
         * The following combinations are converted:
         * \n  newline
         * \r  carraige return
         * \f  form feed
         * \t  tab
         * \\  backslash
         * \u0000  unicode character
         * Any other slash is ignored, so
         * \b  becomes 'b'.
         */#char#[#]#ch#=#new#char#[#s#.#length#(#)#+#1#]#;#s#.#getChars#(#0#,#s#.#length#(#)#,#ch#,#0#)#;#ch#[#s#.#length#(#)#]#=#'\n'#;#StringBuffer#buffy#=#new#StringBuffer#(#s#.#length#(#)#)#;#for#(#int#i#=#0#;#i#<#ch#.#length#;#i#++#)#{#char#c#=#ch#[#i#]#;#if#(#c#==#'\n'#)#{#// we have hit out end-of-string marker#break#;#}#else#if#(#c#==#'\\'#)#{#// possibly an escape sequence#c#=#ch#[#++#i#]#;#if#(#c#==#'n'#)#buffy#.#append#(#'\n'#)#;#else#if#(#c#==#'r'#)#buffy#.#append#(#'\r'#)#;#else#if#(#c#==#'f'#)#buffy#.#append#(#'\f'#)#;#else#if#(#c#==#'t'#)#buffy#.#append#(#'\t'#)#;#else#if#(#c#==#'u'#)#{#// handle unicode escapes#c#=#unescapeUnicode#(#ch#,#i#+#1#)#;#i#+=#4#;#buffy#.#append#(#c#)#;#}#else#buffy#.#append#(#c#)#;#}#else#{#buffy#.#append#(#c#)#;#}#}#return#buffy#.#toString#(#)#;#}##char#unescapeUnicode#(#char#[#]#ch#,#int#i#)#{#String#s#=#new#String#(#ch#,#i#,#4#)#;#return#(#char#)#Integer#.#parseInt#(#s#,#16#)#;#}##String#escapeValue#(#String#s#)#{#return#escape#(#s#,#false#)#;#}##String#escapeName#(#String#s#)#{#return#escape#(#s#,#true#)#;#}##String#escape#(#String#s#,#boolean#escapeAllSpaces#)#{#if#(#s#==#null#)#{#return#null#;#}#char#[#]#ch#=#new#char#[#s#.#length#(#)#]#;#s#.#getChars#(#0#,#s#.#length#(#)#,#ch#,#0#)#;#String#forEscaping#=#"\t\f\r\n\\:=#!"#;#String#escaped#=#"tfrn\\:=#!"#;#StringBuffer#buffy#=#new#StringBuffer#(#s#.#length#(#)#)#;#boolean#leadingSpace#=#true#;#for#(#int#i#=#0#;#i#<#ch#.#length#;#i#++#)#{#char#c#=#ch#[#i#]#;#if#(#c#==#' '#)#{#if#(#escapeAllSpaces#||#leadingSpace#)#{#buffy#.#append#(#"\\"#)#;#}#}#else#{#leadingSpace#=#false#;#}#int#p#=#forEscaping#.#indexOf#(#c#)#;#if#(#p#!=#-#1#)#{#buffy#.#append#(#"\\"#)#.#append#(#escaped#.#substring#(#p#,#p#+#1#)#)#;#}#else#if#(#c#<#0x0020#||#c#>#0x007e#)#{#buffy#.#append#(#escapeUnicode#(#c#)#)#;#}#else#{#buffy#.#append#(#c#)#;#}#}#return#buffy#.#toString#(#)#;#}##String#escapeUnicode#(#char#ch#)#{#StringBuffer#buffy#=#new#StringBuffer#(#"\\u"#)#;#String#hex#=#Integer#.#toHexString#(#(#int#)#ch#)#;#buffy#.#append#(#"0000"#.#substring#(#4#-#hex#.#length#(#)#)#)#;#buffy#.#append#(#hex#)#;#return#buffy#.#toString#(#)#;#}##void#removeCommentsEndingAt#(#int#pos#)#{#/* We want to remove comments preceding this position. Step
         * back counting blank lines (call this range B1) until we hit
         * something non-blank. If what we hit is not a comment, then
         * exit. If what we hit is a comment, then step back counting
         * comment lines (call this range C1). Nullify lines in C1 and
         * B1.
         */#int#end#=#pos#-#1#;#// step pos back until it hits something non-blank#for#(#pos#=#end#;#pos#>#0#;#pos#--#)#{#if#(#!#(#logicalLines#.#get#(#pos#)#instanceof#Blank#)#)#{#break#;#}#}#// if the thing it hits is not a comment, then we have nothing#// to remove#if#(#!#(#logicalLines#.#get#(#pos#)#instanceof#Comment#)#)#{#return#;#}#// step back until we hit the start of the comment#for#(#;#pos#>=#0#;#pos#--#)#{#if#(#!#(#logicalLines#.#get#(#pos#)#instanceof#Comment#)#)#{#break#;#}#}#// now we want to delete from pos+1 to end#for#(#pos#++#;#pos#<=#end#;#pos#++#)#{#logicalLines#.#set#(#pos#,#null#)#;#}#}##void#setText#(#String#text#)#{#this#.#text#=#text#;#}##String#toString#(#)#{#return#text#;#}##String#getName#(#)#{#return#name#;#}##String#getValue#(#)#{#return#value#;#}##void#setValue#(#String#value#)#{#this#.#value#=#value#;#setText#(#name#+#"="#+#value#)#;#}##boolean#isNew#(#)#{#return#added#;#}##void#setNew#(#boolean#val#)#{#added#=#val#;#}##Object#clone#(#)#{#Object#dolly#=#null#;#try#{#dolly#=#super#.#clone#(#)#;#}#catch#(#CloneNotSupportedException#e#)#{#// should be fine#e#.#printStackTrace#(#)#;#}#return#dolly#;#}##void#parsePair#(#String#text#)#{#// need to find first non-escaped '=', ':', '\t' or ' '.#int#pos#=#findFirstSeparator#(#text#)#;#if#(#pos#==#-#1#)#{#// trim leading whitespace only#name#=#text#;#value#=#null#;#}#else#{#name#=#text#.#substring#(#0#,#pos#)#;#value#=#text#.#substring#(#pos#+#1#,#text#.#length#(#)#)#;#}#// trim leading whitespace only#name#=#stripStart#(#name#,#" \t\f"#)#;#}##String#stripStart#(#String#s#,#String#chars#)#{#if#(#s#==#null#)#{#return#null#;#}#int#i#=#0#;#for#(#;#i#<#s#.#length#(#)#;#i#++#)#{#if#(#chars#.#indexOf#(#s#.#charAt#(#i#)#)#==#-#1#)#{#break#;#}#}#if#(#i#==#s#.#length#(#)#)#{#return#""#;#}#return#s#.#substring#(#i#)#;#}##int#findFirstSeparator#(#String#s#)#{#// Replace double backslashes with underscores so that they don't#// confuse us looking for '\t' or '\=', for example, but they also#// don't change the position of other characters#s#=#s#.#replaceAll#(#"\\\\\\\\"#,#"__"#)#;#// Replace single backslashes followed by separators, so we don't#// pick them up#s#=#s#.#replaceAll#(#"\\\\="#,#"__"#)#;#s#=#s#.#replaceAll#(#"\\\\:"#,#"__"#)#;#s#=#s#.#replaceAll#(#"\\\\ "#,#"__"#)#;#s#=#s#.#replaceAll#(#"\\\\t"#,#"__"#)#;#// Now only the unescaped separators are left#return#indexOfAny#(#s#,#" :=\t"#)#;#}##int#indexOfAny#(#String#s#,#String#chars#)#{#if#(#s#==#null#||#chars#==#null#)#{#return#-#1#;#}#int#p#=#s#.#length#(#)#+#1#;#for#(#int#i#=#0#;#i#<#chars#.#length#(#)#;#i#++#)#{#int#x#=#s#.#indexOf#(#chars#.#charAt#(#i#)#)#;#if#(#x#!=#-#1#&&#x#<#p#)#{#p#=#x#;#}#}#if#(#p#==#s#.#length#(#)#+#1#)#{#return#-#1#;#}#return#p#;#}##