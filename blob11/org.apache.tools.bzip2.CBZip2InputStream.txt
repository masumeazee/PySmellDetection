void#reportCRCError#(#)#throws#IOException#{#// The clean way would be to throw an exception.#//throw new IOException("crc error");#// Just print a message, like the previous versions of this class did#System#.#err#.#println#(#"BZip2 CRC error"#)#;#}##void#makeMaps#(#)#{#final#boolean#[#]#inUse#=#this#.#data#.#inUse#;#final#byte#[#]#seqToUnseq#=#this#.#data#.#seqToUnseq#;#int#nInUseShadow#=#0#;#for#(#int#i#=#0#;#i#<#256#;#i#++#)#{#if#(#inUse#[#i#]#)#seqToUnseq#[#nInUseShadow#++#]#=#(#byte#)#i#;#}#this#.#nInUse#=#nInUseShadow#;#}##int#read#(#)#throws#IOException#{#if#(#this#.#in#!=#null#)#{#return#read0#(#)#;#}#else#{#throw#new#IOException#(#"stream closed"#)#;#}#}##int#read#(#final#byte#[#]#dest#,#final#int#offs#,#final#int#len#)#throws#IOException#{#if#(#offs#<#0#)#{#throw#new#IndexOutOfBoundsException#(#"offs("#+#offs#+#") < 0."#)#;#}#if#(#len#<#0#)#{#throw#new#IndexOutOfBoundsException#(#"len("#+#len#+#") < 0."#)#;#}#if#(#offs#+#len#>#dest#.#length#)#{#throw#new#IndexOutOfBoundsException#(#"offs("#+#offs#+#") + len("#+#len#+#") > dest.length("#+#dest#.#length#+#")."#)#;#}#if#(#this#.#in#==#null#)#{#throw#new#IOException#(#"stream closed"#)#;#}#final#int#hi#=#offs#+#len#;#int#destOffs#=#offs#;#for#(#int#b#;#(#destOffs#<#hi#)#&&#(#(#b#=#read0#(#)#)#>=#0#)#;#)#{#dest#[#destOffs#++#]#=#(#byte#)#b#;#}#return#(#destOffs#==#offs#)#?#-#1#:#(#destOffs#-#offs#)#;#}##int#read0#(#)#throws#IOException#{#final#int#retChar#=#this#.#currentChar#;#switch#(#this#.#currentState#)#{#case#EOF#:#return#-#1#;#case#START_BLOCK_STATE#:#throw#new#IllegalStateException#(#)#;#case#RAND_PART_A_STATE#:#throw#new#IllegalStateException#(#)#;#case#RAND_PART_B_STATE#:#setupRandPartB#(#)#;#break#;#case#RAND_PART_C_STATE#:#setupRandPartC#(#)#;#break#;#case#NO_RAND_PART_A_STATE#:#throw#new#IllegalStateException#(#)#;#case#NO_RAND_PART_B_STATE#:#setupNoRandPartB#(#)#;#break#;#case#NO_RAND_PART_C_STATE#:#setupNoRandPartC#(#)#;#break#;#default#:#throw#new#IllegalStateException#(#)#;#}#return#retChar#;#}##void#init#(#)#throws#IOException#{#if#(#null#==#in#)#{#throw#new#IOException#(#"No InputStream"#)#;#}#if#(#in#.#available#(#)#==#0#)#{#throw#new#IOException#(#"Empty InputStream"#)#;#}#int#magic2#=#this#.#in#.#read#(#)#;#if#(#magic2#!=#'h'#)#{#throw#new#IOException#(#"Stream is not BZip2 formatted: expected 'h'"#+#" as first byte but got '"#+#(#char#)#magic2#+#"'"#)#;#}#int#blockSize#=#this#.#in#.#read#(#)#;#if#(#(#blockSize#<#'1'#)#||#(#blockSize#>#'9'#)#)#{#throw#new#IOException#(#"Stream is not BZip2 formatted: illegal "#+#"blocksize "#+#(#char#)#blockSize#)#;#}#this#.#blockSize100k#=#blockSize#-#'0'#;#initBlock#(#)#;#setupBlock#(#)#;#}##void#initBlock#(#)#throws#IOException#{#char#magic0#=#bsGetUByte#(#)#;#char#magic1#=#bsGetUByte#(#)#;#char#magic2#=#bsGetUByte#(#)#;#char#magic3#=#bsGetUByte#(#)#;#char#magic4#=#bsGetUByte#(#)#;#char#magic5#=#bsGetUByte#(#)#;#if#(#magic0#==#0x17#&&#magic1#==#0x72#&&#magic2#==#0x45#&&#magic3#==#0x38#&&#magic4#==#0x50#&&#magic5#==#0x90#)#{#complete#(#)#;#// end of file#}#else#if#(#magic0#!=#0x31#||#// '1'#magic1#!=#0x41#||#// ')'#magic2#!=#0x59#||#// 'Y'#magic3#!=#0x26#||#// '&'#magic4#!=#0x53#||#// 'S'#magic5#!=#0x59#// 'Y'#)#{#this#.#currentState#=#EOF#;#throw#new#IOException#(#"bad block header"#)#;#}#else#{#this#.#storedBlockCRC#=#bsGetInt#(#)#;#this#.#blockRandomised#=#bsR#(#1#)#==#1#;#/**
             * Allocate data here instead in constructor, so we do not
             * allocate it if the input file is empty.
             */#if#(#this#.#data#==#null#)#{#this#.#data#=#new#Data#(#this#.#blockSize100k#)#;#}#// currBlockNo++;#getAndMoveToFrontDecode#(#)#;#this#.#crc#.#initialiseCRC#(#)#;#this#.#currentState#=#START_BLOCK_STATE#;#}#}##void#endBlock#(#)#throws#IOException#{#this#.#computedBlockCRC#=#this#.#crc#.#getFinalCRC#(#)#;#// A bad CRC is considered a fatal error.#if#(#this#.#storedBlockCRC#!=#this#.#computedBlockCRC#)#{#// make next blocks readable without error#// (repair feature, not yet documented, not tested)#this#.#computedCombinedCRC#=#(#this#.#storedCombinedCRC#<#<#1#)#|#(#this#.#storedCombinedCRC#>#>#>#31#)#;#this#.#computedCombinedCRC#^=#this#.#storedBlockCRC#;#reportCRCError#(#)#;#}#this#.#computedCombinedCRC#=#(#this#.#computedCombinedCRC#<#<#1#)#|#(#this#.#computedCombinedCRC#>#>#>#31#)#;#this#.#computedCombinedCRC#^=#this#.#computedBlockCRC#;#}##void#complete#(#)#throws#IOException#{#this#.#storedCombinedCRC#=#bsGetInt#(#)#;#this#.#currentState#=#EOF#;#this#.#data#=#null#;#if#(#this#.#storedCombinedCRC#!=#this#.#computedCombinedCRC#)#{#reportCRCError#(#)#;#}#}##void#close#(#)#throws#IOException#{#InputStream#inShadow#=#this#.#in#;#if#(#inShadow#!=#null#)#{#try#{#if#(#inShadow#!=#System#.#in#)#{#inShadow#.#close#(#)#;#}#}#finally#{#this#.#data#=#null#;#this#.#in#=#null#;#}#}#}##int#bsR#(#final#int#n#)#throws#IOException#{#int#bsLiveShadow#=#this#.#bsLive#;#int#bsBuffShadow#=#this#.#bsBuff#;#if#(#bsLiveShadow#<#n#)#{#final#InputStream#inShadow#=#this#.#in#;#do#{#int#thech#=#inShadow#.#read#(#)#;#if#(#thech#<#0#)#{#throw#new#IOException#(#"unexpected end of stream"#)#;#}#bsBuffShadow#=#(#bsBuffShadow#<#<#8#)#|#thech#;#bsLiveShadow#+=#8#;#}#while#(#bsLiveShadow#<#n#)#;#this#.#bsBuff#=#bsBuffShadow#;#}#this#.#bsLive#=#bsLiveShadow#-#n#;#return#(#bsBuffShadow#>#>#(#bsLiveShadow#-#n#)#)#&#(#(#1#<#<#n#)#-#1#)#;#}##boolean#bsGetBit#(#)#throws#IOException#{#int#bsLiveShadow#=#this#.#bsLive#;#int#bsBuffShadow#=#this#.#bsBuff#;#if#(#bsLiveShadow#<#1#)#{#int#thech#=#this#.#in#.#read#(#)#;#if#(#thech#<#0#)#{#throw#new#IOException#(#"unexpected end of stream"#)#;#}#bsBuffShadow#=#(#bsBuffShadow#<#<#8#)#|#thech#;#bsLiveShadow#+=#8#;#this#.#bsBuff#=#bsBuffShadow#;#}#this#.#bsLive#=#bsLiveShadow#-#1#;#return#(#(#bsBuffShadow#>#>#(#bsLiveShadow#-#1#)#)#&#1#)#!=#0#;#}##char#bsGetUByte#(#)#throws#IOException#{#return#(#char#)#bsR#(#8#)#;#}##int#bsGetInt#(#)#throws#IOException#{#return#(#(#(#(#(#bsR#(#8#)#<#<#8#)#|#bsR#(#8#)#)#<#<#8#)#|#bsR#(#8#)#)#<#<#8#)#|#bsR#(#8#)#;#}##void#hbCreateDecodeTables#(#final#int#[#]#limit#,#final#int#[#]#base#,#final#int#[#]#perm#,#final#char#[#]#length#,#final#int#minLen#,#final#int#maxLen#,#final#int#alphaSize#)#{#for#(#int#i#=#minLen#,#pp#=#0#;#i#<=#maxLen#;#i#++#)#{#for#(#int#j#=#0#;#j#<#alphaSize#;#j#++#)#{#if#(#length#[#j#]#==#i#)#{#perm#[#pp#++#]#=#j#;#}#}#}#for#(#int#i#=#MAX_CODE_LEN#;#--#i#>#0#;#)#{#base#[#i#]#=#0#;#limit#[#i#]#=#0#;#}#for#(#int#i#=#0#;#i#<#alphaSize#;#i#++#)#{#base#[#length#[#i#]#+#1#]#++#;#}#for#(#int#i#=#1#,#b#=#base#[#0#]#;#i#<#MAX_CODE_LEN#;#i#++#)#{#b#+=#base#[#i#]#;#base#[#i#]#=#b#;#}#for#(#int#i#=#minLen#,#vec#=#0#,#b#=#base#[#i#]#;#i#<=#maxLen#;#i#++#)#{#final#int#nb#=#base#[#i#+#1#]#;#vec#+=#nb#-#b#;#b#=#nb#;#limit#[#i#]#=#vec#-#1#;#vec#<<=#1#;#}#for#(#int#i#=#minLen#+#1#;#i#<=#maxLen#;#i#++#)#{#base#[#i#]#=#(#(#limit#[#i#-#1#]#+#1#)#<#<#1#)#-#base#[#i#]#;#}#}##void#recvDecodingTables#(#)#throws#IOException#{#final#Data#dataShadow#=#this#.#data#;#final#boolean#[#]#inUse#=#dataShadow#.#inUse#;#final#byte#[#]#pos#=#dataShadow#.#recvDecodingTables_pos#;#final#byte#[#]#selector#=#dataShadow#.#selector#;#final#byte#[#]#selectorMtf#=#dataShadow#.#selectorMtf#;#int#inUse16#=#0#;#/* Receive the mapping table */#for#(#int#i#=#0#;#i#<#16#;#i#++#)#{#if#(#bsGetBit#(#)#)#{#inUse16#|=#1#<#<#i#;#}#}#for#(#int#i#=#256#;#--#i#>=#0#;#)#{#inUse#[#i#]#=#false#;#}#for#(#int#i#=#0#;#i#<#16#;#i#++#)#{#if#(#(#inUse16#&#(#1#<#<#i#)#)#!=#0#)#{#final#int#i16#=#i#<#<#4#;#for#(#int#j#=#0#;#j#<#16#;#j#++#)#{#if#(#bsGetBit#(#)#)#{#inUse#[#i16#+#j#]#=#true#;#}#}#}#}#makeMaps#(#)#;#final#int#alphaSize#=#this#.#nInUse#+#2#;#/* Now the selectors */#final#int#nGroups#=#bsR#(#3#)#;#final#int#nSelectors#=#bsR#(#15#)#;#for#(#int#i#=#0#;#i#<#nSelectors#;#i#++#)#{#int#j#=#0#;#while#(#bsGetBit#(#)#)#{#j#++#;#}#selectorMtf#[#i#]#=#(#byte#)#j#;#}#/* Undo the MTF values for the selectors. */#for#(#int#v#=#nGroups#;#--#v#>=#0#;#)#{#pos#[#v#]#=#(#byte#)#v#;#}#for#(#int#i#=#0#;#i#<#nSelectors#;#i#++#)#{#int#v#=#selectorMtf#[#i#]#&#0xff#;#final#byte#tmp#=#pos#[#v#]#;#while#(#v#>#0#)#{#// nearly all times v is zero, 4 in most other cases#pos#[#v#]#=#pos#[#v#-#1#]#;#v#--#;#}#pos#[#0#]#=#tmp#;#selector#[#i#]#=#tmp#;#}#final#char#[#]#[#]#len#=#dataShadow#.#temp_charArray2d#;#/* Now the coding tables */#for#(#int#t#=#0#;#t#<#nGroups#;#t#++#)#{#int#curr#=#bsR#(#5#)#;#final#char#[#]#len_t#=#len#[#t#]#;#for#(#int#i#=#0#;#i#<#alphaSize#;#i#++#)#{#while#(#bsGetBit#(#)#)#{#curr#+=#bsGetBit#(#)#?#-#1#:#1#;#}#len_t#[#i#]#=#(#char#)#curr#;#}#}#// finally create the Huffman tables#createHuffmanDecodingTables#(#alphaSize#,#nGroups#)#;#}##void#createHuffmanDecodingTables#(#final#int#alphaSize#,#final#int#nGroups#)#{#final#Data#dataShadow#=#this#.#data#;#final#char#[#]#[#]#len#=#dataShadow#.#temp_charArray2d#;#final#int#[#]#minLens#=#dataShadow#.#minLens#;#final#int#[#]#[#]#limit#=#dataShadow#.#limit#;#final#int#[#]#[#]#base#=#dataShadow#.#base#;#final#int#[#]#[#]#perm#=#dataShadow#.#perm#;#for#(#int#t#=#0#;#t#<#nGroups#;#t#++#)#{#int#minLen#=#32#;#int#maxLen#=#0#;#final#char#[#]#len_t#=#len#[#t#]#;#for#(#int#i#=#alphaSize#;#--#i#>=#0#;#)#{#final#char#lent#=#len_t#[#i#]#;#if#(#lent#>#maxLen#)#{#maxLen#=#lent#;#}#if#(#lent#<#minLen#)#{#minLen#=#lent#;#}#}#hbCreateDecodeTables#(#limit#[#t#]#,#base#[#t#]#,#perm#[#t#]#,#len#[#t#]#,#minLen#,#maxLen#,#alphaSize#)#;#minLens#[#t#]#=#minLen#;#}#}##void#getAndMoveToFrontDecode#(#)#throws#IOException#{#this#.#origPtr#=#bsR#(#24#)#;#recvDecodingTables#(#)#;#final#InputStream#inShadow#=#this#.#in#;#final#Data#dataShadow#=#this#.#data#;#final#byte#[#]#ll8#=#dataShadow#.#ll8#;#final#int#[#]#unzftab#=#dataShadow#.#unzftab#;#final#byte#[#]#selector#=#dataShadow#.#selector#;#final#byte#[#]#seqToUnseq#=#dataShadow#.#seqToUnseq#;#final#char#[#]#yy#=#dataShadow#.#getAndMoveToFrontDecode_yy#;#final#int#[#]#minLens#=#dataShadow#.#minLens#;#final#int#[#]#[#]#limit#=#dataShadow#.#limit#;#final#int#[#]#[#]#base#=#dataShadow#.#base#;#final#int#[#]#[#]#perm#=#dataShadow#.#perm#;#final#int#limitLast#=#this#.#blockSize100k#*#100000#;#/*
          Setting up the unzftab entries here is not strictly
          necessary, but it does save having to do it later
          in a separate pass, and so saves a block's worth of
          cache misses.
        */#for#(#int#i#=#256#;#--#i#>=#0#;#)#{#yy#[#i#]#=#(#char#)#i#;#unzftab#[#i#]#=#0#;#}#int#groupNo#=#0#;#int#groupPos#=#G_SIZE#-#1#;#final#int#eob#=#this#.#nInUse#+#1#;#int#nextSym#=#getAndMoveToFrontDecode0#(#0#)#;#int#bsBuffShadow#=#this#.#bsBuff#;#int#bsLiveShadow#=#this#.#bsLive#;#int#lastShadow#=#-#1#;#int#zt#=#selector#[#groupNo#]#&#0xff#;#int#[#]#base_zt#=#base#[#zt#]#;#int#[#]#limit_zt#=#limit#[#zt#]#;#int#[#]#perm_zt#=#perm#[#zt#]#;#int#minLens_zt#=#minLens#[#zt#]#;#while#(#nextSym#!=#eob#)#{#if#(#(#nextSym#==#RUNA#)#||#(#nextSym#==#RUNB#)#)#{#int#s#=#-#1#;#for#(#int#n#=#1#;#true#;#n#<<=#1#)#{#if#(#nextSym#==#RUNA#)#{#s#+=#n#;#}#else#if#(#nextSym#==#RUNB#)#{#s#+=#n#<#<#1#;#}#else#{#break#;#}#if#(#groupPos#==#0#)#{#groupPos#=#G_SIZE#-#1#;#zt#=#selector#[#++#groupNo#]#&#0xff#;#base_zt#=#base#[#zt#]#;#limit_zt#=#limit#[#zt#]#;#perm_zt#=#perm#[#zt#]#;#minLens_zt#=#minLens#[#zt#]#;#}#else#{#groupPos#--#;#}#int#zn#=#minLens_zt#;#// Inlined:#// int zvec = bsR(zn);#while#(#bsLiveShadow#<#zn#)#{#final#int#thech#=#inShadow#.#read#(#)#;#if#(#thech#>=#0#)#{#bsBuffShadow#=#(#bsBuffShadow#<#<#8#)#|#thech#;#bsLiveShadow#+=#8#;#continue#;#}#else#{#throw#new#IOException#(#"unexpected end of stream"#)#;#}#}#int#zvec#=#(#bsBuffShadow#>#>#(#bsLiveShadow#-#zn#)#)#&#(#(#1#<#<#zn#)#-#1#)#;#bsLiveShadow#-=#zn#;#while#(#zvec#>#limit_zt#[#zn#]#)#{#zn#++#;#while#(#bsLiveShadow#<#1#)#{#final#int#thech#=#inShadow#.#read#(#)#;#if#(#thech#>=#0#)#{#bsBuffShadow#=#(#bsBuffShadow#<#<#8#)#|#thech#;#bsLiveShadow#+=#8#;#continue#;#}#else#{#throw#new#IOException#(#"unexpected end of stream"#)#;#}#}#bsLiveShadow#--#;#zvec#=#(#zvec#<#<#1#)#|#(#(#bsBuffShadow#>#>#bsLiveShadow#)#&#1#)#;#}#nextSym#=#perm_zt#[#zvec#-#base_zt#[#zn#]#]#;#}#final#byte#ch#=#seqToUnseq#[#yy#[#0#]#]#;#unzftab#[#ch#&#0xff#]#+=#s#+#1#;#while#(#s#--#>=#0#)#{#ll8#[#++#lastShadow#]#=#ch#;#}#if#(#lastShadow#>=#limitLast#)#{#throw#new#IOException#(#"block overrun"#)#;#}#}#else#{#if#(#++#lastShadow#>=#limitLast#)#{#throw#new#IOException#(#"block overrun"#)#;#}#final#char#tmp#=#yy#[#nextSym#-#1#]#;#unzftab#[#seqToUnseq#[#tmp#]#&#0xff#]#++#;#ll8#[#lastShadow#]#=#seqToUnseq#[#tmp#]#;#/*
                  This loop is hammered during decompression,
                  hence avoid native method call overhead of
                  System.arraycopy for very small ranges to copy.
                */#if#(#nextSym#<=#16#)#{#for#(#int#j#=#nextSym#-#1#;#j#>#0#;#)#{#yy#[#j#]#=#yy#[#--#j#]#;#}#}#else#{#System#.#arraycopy#(#yy#,#0#,#yy#,#1#,#nextSym#-#1#)#;#}#yy#[#0#]#=#tmp#;#if#(#groupPos#==#0#)#{#groupPos#=#G_SIZE#-#1#;#zt#=#selector#[#++#groupNo#]#&#0xff#;#base_zt#=#base#[#zt#]#;#limit_zt#=#limit#[#zt#]#;#perm_zt#=#perm#[#zt#]#;#minLens_zt#=#minLens#[#zt#]#;#}#else#{#groupPos#--#;#}#int#zn#=#minLens_zt#;#// Inlined:#// int zvec = bsR(zn);#while#(#bsLiveShadow#<#zn#)#{#final#int#thech#=#inShadow#.#read#(#)#;#if#(#thech#>=#0#)#{#bsBuffShadow#=#(#bsBuffShadow#<#<#8#)#|#thech#;#bsLiveShadow#+=#8#;#continue#;#}#else#{#throw#new#IOException#(#"unexpected end of stream"#)#;#}#}#int#zvec#=#(#bsBuffShadow#>#>#(#bsLiveShadow#-#zn#)#)#&#(#(#1#<#<#zn#)#-#1#)#;#bsLiveShadow#-=#zn#;#while#(#zvec#>#limit_zt#[#zn#]#)#{#zn#++#;#while#(#bsLiveShadow#<#1#)#{#final#int#thech#=#inShadow#.#read#(#)#;#if#(#thech#>=#0#)#{#bsBuffShadow#=#(#bsBuffShadow#<#<#8#)#|#thech#;#bsLiveShadow#+=#8#;#continue#;#}#else#{#throw#new#IOException#(#"unexpected end of stream"#)#;#}#}#bsLiveShadow#--#;#zvec#=#(#zvec#<#<#1#)#|#(#(#bsBuffShadow#>#>#bsLiveShadow#)#&#1#)#;#}#nextSym#=#perm_zt#[#zvec#-#base_zt#[#zn#]#]#;#}#}#this#.#last#=#lastShadow#;#this#.#bsLive#=#bsLiveShadow#;#this#.#bsBuff#=#bsBuffShadow#;#}##int#getAndMoveToFrontDecode0#(#final#int#groupNo#)#throws#IOException#{#final#InputStream#inShadow#=#this#.#in#;#final#Data#dataShadow#=#this#.#data#;#final#int#zt#=#dataShadow#.#selector#[#groupNo#]#&#0xff#;#final#int#[#]#limit_zt#=#dataShadow#.#limit#[#zt#]#;#int#zn#=#dataShadow#.#minLens#[#zt#]#;#int#zvec#=#bsR#(#zn#)#;#int#bsLiveShadow#=#this#.#bsLive#;#int#bsBuffShadow#=#this#.#bsBuff#;#while#(#zvec#>#limit_zt#[#zn#]#)#{#zn#++#;#while#(#bsLiveShadow#<#1#)#{#final#int#thech#=#inShadow#.#read#(#)#;#if#(#thech#>=#0#)#{#bsBuffShadow#=#(#bsBuffShadow#<#<#8#)#|#thech#;#bsLiveShadow#+=#8#;#continue#;#}#else#{#throw#new#IOException#(#"unexpected end of stream"#)#;#}#}#bsLiveShadow#--#;#zvec#=#(#zvec#<#<#1#)#|#(#(#bsBuffShadow#>#>#bsLiveShadow#)#&#1#)#;#}#this#.#bsLive#=#bsLiveShadow#;#this#.#bsBuff#=#bsBuffShadow#;#return#dataShadow#.#perm#[#zt#]#[#zvec#-#dataShadow#.#base#[#zt#]#[#zn#]#]#;#}##void#setupBlock#(#)#throws#IOException#{#if#(#this#.#data#==#null#)#{#return#;#}#final#int#[#]#cftab#=#this#.#data#.#cftab#;#final#int#[#]#tt#=#this#.#data#.#initTT#(#this#.#last#+#1#)#;#final#byte#[#]#ll8#=#this#.#data#.#ll8#;#cftab#[#0#]#=#0#;#System#.#arraycopy#(#this#.#data#.#unzftab#,#0#,#cftab#,#1#,#256#)#;#for#(#int#i#=#1#,#c#=#cftab#[#0#]#;#i#<=#256#;#i#++#)#{#c#+=#cftab#[#i#]#;#cftab#[#i#]#=#c#;#}#for#(#int#i#=#0#,#lastShadow#=#this#.#last#;#i#<=#lastShadow#;#i#++#)#{#tt#[#cftab#[#ll8#[#i#]#&#0xff#]#++#]#=#i#;#}#if#(#(#this#.#origPtr#<#0#)#||#(#this#.#origPtr#>=#tt#.#length#)#)#{#throw#new#IOException#(#"stream corrupted"#)#;#}#this#.#su_tPos#=#tt#[#this#.#origPtr#]#;#this#.#su_count#=#0#;#this#.#su_i2#=#0#;#this#.#su_ch2#=#256#;#/* not a char and not EOF */#if#(#this#.#blockRandomised#)#{#this#.#su_rNToGo#=#0#;#this#.#su_rTPos#=#0#;#setupRandPartA#(#)#;#}#else#{#setupNoRandPartA#(#)#;#}#}##void#setupRandPartA#(#)#throws#IOException#{#if#(#this#.#su_i2#<=#this#.#last#)#{#this#.#su_chPrev#=#this#.#su_ch2#;#int#su_ch2Shadow#=#this#.#data#.#ll8#[#this#.#su_tPos#]#&#0xff#;#this#.#su_tPos#=#this#.#data#.#tt#[#this#.#su_tPos#]#;#if#(#this#.#su_rNToGo#==#0#)#{#this#.#su_rNToGo#=#BZip2Constants#.#rNums#[#this#.#su_rTPos#]#-#1#;#if#(#++#this#.#su_rTPos#==#512#)#{#this#.#su_rTPos#=#0#;#}#}#else#{#this#.#su_rNToGo#--#;#}#this#.#su_ch2#=#su_ch2Shadow#^=#(#this#.#su_rNToGo#==#1#)#?#1#:#0#;#this#.#su_i2#++#;#this#.#currentChar#=#su_ch2Shadow#;#this#.#currentState#=#RAND_PART_B_STATE#;#this#.#crc#.#updateCRC#(#su_ch2Shadow#)#;#}#else#{#endBlock#(#)#;#initBlock#(#)#;#setupBlock#(#)#;#}#}##void#setupNoRandPartA#(#)#throws#IOException#{#if#(#this#.#su_i2#<=#this#.#last#)#{#this#.#su_chPrev#=#this#.#su_ch2#;#int#su_ch2Shadow#=#this#.#data#.#ll8#[#this#.#su_tPos#]#&#0xff#;#this#.#su_ch2#=#su_ch2Shadow#;#this#.#su_tPos#=#this#.#data#.#tt#[#this#.#su_tPos#]#;#this#.#su_i2#++#;#this#.#currentChar#=#su_ch2Shadow#;#this#.#currentState#=#NO_RAND_PART_B_STATE#;#this#.#crc#.#updateCRC#(#su_ch2Shadow#)#;#}#else#{#this#.#currentState#=#NO_RAND_PART_A_STATE#;#endBlock#(#)#;#initBlock#(#)#;#setupBlock#(#)#;#}#}##void#setupRandPartB#(#)#throws#IOException#{#if#(#this#.#su_ch2#!=#this#.#su_chPrev#)#{#this#.#currentState#=#RAND_PART_A_STATE#;#this#.#su_count#=#1#;#setupRandPartA#(#)#;#}#else#if#(#++#this#.#su_count#>=#4#)#{#this#.#su_z#=#(#char#)#(#this#.#data#.#ll8#[#this#.#su_tPos#]#&#0xff#)#;#this#.#su_tPos#=#this#.#data#.#tt#[#this#.#su_tPos#]#;#if#(#this#.#su_rNToGo#==#0#)#{#this#.#su_rNToGo#=#BZip2Constants#.#rNums#[#this#.#su_rTPos#]#-#1#;#if#(#++#this#.#su_rTPos#==#512#)#{#this#.#su_rTPos#=#0#;#}#}#else#{#this#.#su_rNToGo#--#;#}#this#.#su_j2#=#0#;#this#.#currentState#=#RAND_PART_C_STATE#;#if#(#this#.#su_rNToGo#==#1#)#{#this#.#su_z#^=#1#;#}#setupRandPartC#(#)#;#}#else#{#this#.#currentState#=#RAND_PART_A_STATE#;#setupRandPartA#(#)#;#}#}##void#setupRandPartC#(#)#throws#IOException#{#if#(#this#.#su_j2#<#this#.#su_z#)#{#this#.#currentChar#=#this#.#su_ch2#;#this#.#crc#.#updateCRC#(#this#.#su_ch2#)#;#this#.#su_j2#++#;#}#else#{#this#.#currentState#=#RAND_PART_A_STATE#;#this#.#su_i2#++#;#this#.#su_count#=#0#;#setupRandPartA#(#)#;#}#}##void#setupNoRandPartB#(#)#throws#IOException#{#if#(#this#.#su_ch2#!=#this#.#su_chPrev#)#{#this#.#su_count#=#1#;#setupNoRandPartA#(#)#;#}#else#if#(#++#this#.#su_count#>=#4#)#{#this#.#su_z#=#(#char#)#(#this#.#data#.#ll8#[#this#.#su_tPos#]#&#0xff#)#;#this#.#su_tPos#=#this#.#data#.#tt#[#this#.#su_tPos#]#;#this#.#su_j2#=#0#;#setupNoRandPartC#(#)#;#}#else#{#setupNoRandPartA#(#)#;#}#}##void#setupNoRandPartC#(#)#throws#IOException#{#if#(#this#.#su_j2#<#this#.#su_z#)#{#int#su_ch2Shadow#=#this#.#su_ch2#;#this#.#currentChar#=#su_ch2Shadow#;#this#.#crc#.#updateCRC#(#su_ch2Shadow#)#;#this#.#su_j2#++#;#this#.#currentState#=#NO_RAND_PART_C_STATE#;#}#else#{#this#.#su_i2#++#;#this#.#su_count#=#0#;#setupNoRandPartA#(#)#;#}#}##int#[#]#initTT#(#int#length#)#{#int#[#]#ttShadow#=#this#.#tt#;#// tt.length should always be >= length, but theoretically#// it can happen, if the compressor mixed small and large#// blocks.  Normally only the last block will be smaller#// than others.#if#(#(#ttShadow#==#null#)#||#(#ttShadow#.#length#<#length#)#)#{#this#.#tt#=#ttShadow#=#new#int#[#length#]#;#}#return#ttShadow#;#}##