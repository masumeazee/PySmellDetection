List#sortNodes#(#Collection#nodes#,#SortOptions#options#)#{#/*
         * here we want to use the sort algorithm which work on module descriptors : so we first put
         * dependencies on a map from descriptors to dependency, then we sort the keySet (i.e. a
         * collection of descriptors), then we replace in the sorted list each descriptor by the
         * corresponding dependency
         */#Map#dependenciesMap#=#new#LinkedHashMap#(#)#;#List#nulls#=#new#ArrayList#(#)#;#for#(#Iterator#iter#=#nodes#.#iterator#(#)#;#iter#.#hasNext#(#)#;#)#{#IvyNode#node#=#(#IvyNode#)#iter#.#next#(#)#;#if#(#node#.#getDescriptor#(#)#==#null#)#{#nulls#.#add#(#node#)#;#}#else#{#List#n#=#(#List#)#dependenciesMap#.#get#(#node#.#getDescriptor#(#)#)#;#if#(#n#==#null#)#{#n#=#new#ArrayList#(#)#;#dependenciesMap#.#put#(#node#.#getDescriptor#(#)#,#n#)#;#}#n#.#add#(#node#)#;#}#}#List#list#=#sortModuleDescriptors#(#dependenciesMap#.#keySet#(#)#,#options#)#;#final#double#adjustFactor#=#1.3#;#List#ret#=#new#ArrayList#(#(#int#)#(#list#.#size#(#)#*#adjustFactor#+#nulls#.#size#(#)#)#)#;#// attempt to adjust the size to avoid too much list resizing#for#(#int#i#=#0#;#i#<#list#.#size#(#)#;#i#++#)#{#ModuleDescriptor#md#=#(#ModuleDescriptor#)#list#.#get#(#i#)#;#List#n#=#(#List#)#dependenciesMap#.#get#(#md#)#;#ret#.#addAll#(#n#)#;#}#ret#.#addAll#(#0#,#nulls#)#;#return#ret#;#}##List#sortModuleDescriptors#(#Collection#moduleDescriptors#,#SortOptions#options#)#{#Checks#.#checkNotNull#(#options#,#"options"#)#;#ModuleDescriptorSorter#sorter#=#new#ModuleDescriptorSorter#(#moduleDescriptors#,#getVersionMatcher#(#)#,#options#.#getNonMatchingVersionReporter#(#)#,#options#.#isUseCircularDependencyStrategy#(#)#?#getCircularStrategy#(#)#:#IgnoreCircularDependencyStrategy#.#getInstance#(#)#)#;#return#sorter#.#sortModuleDescriptors#(#)#;#}##CircularDependencyStrategy#getCircularStrategy#(#)#{#return#settings#.#getCircularDependencyStrategy#(#)#;#}##VersionMatcher#getVersionMatcher#(#)#{#return#settings#.#getVersionMatcher#(#)#;#}##