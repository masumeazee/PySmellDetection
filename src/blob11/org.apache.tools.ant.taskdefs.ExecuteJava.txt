void#setJavaCommand#(#Commandline#javaCommand#)#{#this#.#javaCommand#=#javaCommand#;#}##void#setClasspath#(#Path#p#)#{#classpath#=#p#;#}##void#setSystemProperties#(#CommandlineJava#.#SysProperties#s#)#{#sysProperties#=#s#;#}##void#setPermissions#(#Permissions#permissions#)#{#perm#=#permissions#;#}##void#setOutput#(#PrintStream#out#)#{#}##void#setTimeout#(#Long#timeout#)#{#this#.#timeout#=#timeout#;#}##void#execute#(#Project#project#)#throws#BuildException#{#final#String#classname#=#javaCommand#.#getExecutable#(#)#;#AntClassLoader#loader#=#null#;#try#{#if#(#sysProperties#!=#null#)#{#sysProperties#.#setSystem#(#)#;#}#Class#target#=#null#;#try#{#if#(#classpath#==#null#)#{#target#=#Class#.#forName#(#classname#)#;#}#else#{#loader#=#project#.#createClassLoader#(#classpath#)#;#loader#.#setParent#(#project#.#getCoreLoader#(#)#)#;#loader#.#setParentFirst#(#false#)#;#loader#.#addJavaLibraries#(#)#;#loader#.#setIsolated#(#true#)#;#loader#.#setThreadContextLoader#(#)#;#loader#.#forceLoadClass#(#classname#)#;#target#=#Class#.#forName#(#classname#,#true#,#loader#)#;#}#}#catch#(#ClassNotFoundException#e#)#{#throw#new#BuildException#(#"Could not find "#+#classname#+#"."#+#" Make sure you have it in your"#+#" classpath"#)#;#}#main#=#target#.#getMethod#(#"main"#,#new#Class#[#]#{#String#[#]#.#class#}#)#;#if#(#main#==#null#)#{#throw#new#BuildException#(#"Could not find main() method in "#+#classname#)#;#}#if#(#(#main#.#getModifiers#(#)#&#Modifier#.#STATIC#)#==#0#)#{#throw#new#BuildException#(#"main() method in "#+#classname#+#" is not declared static"#)#;#}#if#(#timeout#==#null#)#{#run#(#)#;#}#else#{#thread#=#new#Thread#(#this#,#"ExecuteJava"#)#;#Task#currentThreadTask#=#project#.#getThreadTask#(#Thread#.#currentThread#(#)#)#;#// XXX is the following really necessary? it is in the same thread group...#project#.#registerThreadTask#(#thread#,#currentThreadTask#)#;#// if we run into a timeout, the run-away thread shall not#// make the VM run forever - if no timeout occurs, Ant's#// main thread will still be there to let the new thread#// finish#thread#.#setDaemon#(#true#)#;#Watchdog#w#=#new#Watchdog#(#timeout#.#longValue#(#)#)#;#w#.#addTimeoutObserver#(#this#)#;#synchronized#(#this#)#{#thread#.#start#(#)#;#w#.#start#(#)#;#try#{#wait#(#)#;#}#catch#(#InterruptedException#e#)#{#// ignore#}#if#(#timedOut#)#{#project#.#log#(#"Timeout: sub-process interrupted"#,#Project#.#MSG_WARN#)#;#}#else#{#thread#=#null#;#w#.#stop#(#)#;#}#}#}#if#(#caught#!=#null#)#{#throw#caught#;#}#}#catch#(#BuildException#e#)#{#throw#e#;#}#catch#(#SecurityException#e#)#{#throw#e#;#}#catch#(#ThreadDeath#e#)#{#// XXX could perhaps also call thread.stop(); not sure if anyone cares#throw#e#;#}#catch#(#Throwable#e#)#{#throw#new#BuildException#(#e#)#;#}#finally#{#if#(#loader#!=#null#)#{#loader#.#resetThreadContextLoader#(#)#;#loader#.#cleanup#(#)#;#loader#=#null#;#}#if#(#sysProperties#!=#null#)#{#sysProperties#.#restoreSystem#(#)#;#}#}#}##void#run#(#)#{#final#Object#[#]#argument#=#{#javaCommand#.#getArguments#(#)#}#;#try#{#if#(#perm#!=#null#)#{#perm#.#setSecurityManager#(#)#;#}#main#.#invoke#(#null#,#argument#)#;#}#catch#(#InvocationTargetException#e#)#{#Throwable#t#=#e#.#getTargetException#(#)#;#if#(#!#(#t#instanceof#InterruptedException#)#)#{#caught#=#t#;#}#/* else { swallow, probably due to timeout } */#}#catch#(#Throwable#t#)#{#caught#=#t#;#}#finally#{#if#(#perm#!=#null#)#{#perm#.#restoreSecurityManager#(#)#;#}#synchronized#(#this#)#{#notifyAll#(#)#;#}#}#}##void#timeoutOccured#(#Watchdog#w#)#{#if#(#thread#!=#null#)#{#timedOut#=#true#;#thread#.#interrupt#(#)#;#}#notifyAll#(#)#;#}##boolean#killedProcess#(#)#{#return#timedOut#;#}##int#fork#(#ProjectComponent#pc#)#throws#BuildException#{#CommandlineJava#cmdl#=#new#CommandlineJava#(#)#;#cmdl#.#setClassname#(#javaCommand#.#getExecutable#(#)#)#;#String#[#]#args#=#javaCommand#.#getArguments#(#)#;#for#(#int#i#=#0#;#i#<#args#.#length#;#i#++#)#{#cmdl#.#createArgument#(#)#.#setValue#(#args#[#i#]#)#;#}#if#(#classpath#!=#null#)#{#cmdl#.#createClasspath#(#pc#.#getProject#(#)#)#.#append#(#classpath#)#;#}#if#(#sysProperties#!=#null#)#{#cmdl#.#addSysproperties#(#sysProperties#)#;#}#Redirector#redirector#=#new#Redirector#(#pc#)#;#Execute#exe#=#new#Execute#(#redirector#.#createHandler#(#)#,#timeout#==#null#?#null#:#new#ExecuteWatchdog#(#timeout#.#longValue#(#)#)#)#;#exe#.#setAntRun#(#pc#.#getProject#(#)#)#;#if#(#Os#.#isFamily#(#"openvms"#)#)#{#setupCommandLineForVMS#(#exe#,#cmdl#.#getCommandline#(#)#)#;#}#else#{#exe#.#setCommandline#(#cmdl#.#getCommandline#(#)#)#;#}#try#{#int#rc#=#exe#.#execute#(#)#;#redirector#.#complete#(#)#;#return#rc#;#}#catch#(#IOException#e#)#{#throw#new#BuildException#(#e#)#;#}#finally#{#timedOut#=#exe#.#killedProcess#(#)#;#}#}##void#setupCommandLineForVMS#(#Execute#exe#,#String#[#]#command#)#{#//Use the VM launcher instead of shell launcher on VMS#exe#.#setVMLauncher#(#true#)#;#File#vmsJavaOptionFile#=#null#;#try#{#String#[#]#args#=#new#String#[#command#.#length#-#1#]#;#System#.#arraycopy#(#command#,#1#,#args#,#0#,#command#.#length#-#1#)#;#vmsJavaOptionFile#=#JavaEnvUtils#.#createVmsJavaOptionFile#(#args#)#;#//we mark the file to be deleted on exit.#//the alternative would be to cache the filename and delete#//after execution finished, which is much better for long-lived runtimes#//though spawning complicates things...#vmsJavaOptionFile#.#deleteOnExit#(#)#;#String#[#]#vmsCmd#=#{#command#[#0#]#,#"-V"#,#vmsJavaOptionFile#.#getPath#(#)#}#;#exe#.#setCommandline#(#vmsCmd#)#;#}#catch#(#IOException#e#)#{#throw#new#BuildException#(#"Failed to create a temporary file for \"-V\" switch"#)#;#}#}##