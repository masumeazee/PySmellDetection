void#setFrom#(#String#from#)#{#this#.#from#=#from#;#}##void#setTo#(#String#to#)#{#this#.#to#=#to#;#}##String#apply#(#String#elem#)#{#if#(#from#==#null#||#to#==#null#)#{#throw#new#BuildException#(#"Both 'from' and 'to' must be set "#+#"in a map entry"#)#;#}#// If we're on windows, then do the comparison ignoring case#// and treat the two directory characters the same#String#cmpElem#=#onWindows#?#elem#.#toLowerCase#(#)#.#replace#(#'\\'#,#'/'#)#:#elem#;#String#cmpFrom#=#onWindows#?#from#.#toLowerCase#(#)#.#replace#(#'\\'#,#'/'#)#:#from#;#// If the element starts with the configured prefix, then#// convert the prefix to the configured 'to' value.#return#cmpElem#.#startsWith#(#cmpFrom#)#?#to#+#elem#.#substring#(#from#.#length#(#)#)#:#elem#;#}##String#[#]#getValues#(#)#{#return#new#String#[#]#{#"windows"#,#"unix"#,#"netware"#,#"os/2"#,#"tandem"#}#;#}##Path#createPath#(#)#{#if#(#isReference#(#)#)#{#throw#noChildrenAllowed#(#)#;#}#Path#result#=#new#Path#(#getProject#(#)#)#;#add#(#result#)#;#return#result#;#}##void#add#(#ResourceCollection#rc#)#{#if#(#isReference#(#)#)#{#throw#noChildrenAllowed#(#)#;#}#getPath#(#)#.#add#(#rc#)#;#}##Resources#getPath#(#)#{#if#(#path#==#null#)#{#path#=#new#Resources#(#getProject#(#)#)#;#path#.#setCache#(#true#)#;#}#return#path#;#}##MapEntry#createMap#(#)#{#MapEntry#entry#=#new#MapEntry#(#)#;#prefixMap#.#addElement#(#entry#)#;#return#entry#;#}##void#setTargetos#(#String#target#)#{#TargetOs#to#=#new#TargetOs#(#)#;#to#.#setValue#(#target#)#;#setTargetos#(#to#)#;#}##void#setTargetos#(#TargetOs#target#)#{#targetOS#=#target#.#getValue#(#)#;#// Currently, we deal with only two path formats: Unix and Windows#// And Unix is everything that is not Windows#// for NetWare and OS/2, piggy-back on Windows, since in the#// validateSetup code, the same assumptions can be made as#// with windows - that ; is the path separator#targetWindows#=#!#targetOS#.#equals#(#"unix"#)#&&#!#targetOS#.#equals#(#"tandem"#)#;#}##void#setSetonempty#(#boolean#setonempty#)#{#this#.#setonempty#=#setonempty#;#}##void#setProperty#(#String#p#)#{#property#=#p#;#}##void#setRefid#(#Reference#r#)#{#if#(#path#!=#null#)#{#throw#noChildrenAllowed#(#)#;#}#refid#=#r#;#}##void#setPathSep#(#String#sep#)#{#pathSep#=#sep#;#}##void#setDirSep#(#String#sep#)#{#dirSep#=#sep#;#}##void#setPreserveDuplicates#(#boolean#preserveDuplicates#)#{#this#.#preserveDuplicates#=#preserveDuplicates#;#}##boolean#isPreserveDuplicates#(#)#{#return#preserveDuplicates#;#}##boolean#isReference#(#)#{#return#refid#!=#null#;#}##void#execute#(#)#throws#BuildException#{#Resources#savedPath#=#path#;#String#savedPathSep#=#pathSep#;#// may be altered in validateSetup#String#savedDirSep#=#dirSep#;#// may be altered in validateSetup#try#{#// If we are a reference, create a Path from the reference#if#(#isReference#(#)#)#{#Object#o#=#refid#.#getReferencedObject#(#getProject#(#)#)#;#if#(#!#(#o#instanceof#ResourceCollection#)#)#{#throw#new#BuildException#(#"refid '"#+#refid#.#getRefId#(#)#+#"' does not refer to a resource collection."#)#;#}#getPath#(#)#.#add#(#(#ResourceCollection#)#o#)#;#}#validateSetup#(#)#;#// validate our setup#// Currently, we deal with only two path formats: Unix and Windows#// And Unix is everything that is not Windows#// (with the exception for NetWare and OS/2 below)#// for NetWare and OS/2, piggy-back on Windows, since here and#// in the apply code, the same assumptions can be made as with#// windows - that \\ is an OK separator, and do comparisons#// case-insensitive.#String#fromDirSep#=#onWindows#?#"\\"#:#"/"#;#StringBuffer#rslt#=#new#StringBuffer#(#)#;#ResourceCollection#resources#=#isPreserveDuplicates#(#)#?#(#ResourceCollection#)#path#:#new#Union#(#path#)#;#List#ret#=#new#ArrayList#(#)#;#FileNameMapper#mapperImpl#=#mapper#==#null#?#new#IdentityMapper#(#)#:#mapper#.#getImplementation#(#)#;#for#(#Iterator#iter#=#resources#.#iterator#(#)#;#iter#.#hasNext#(#)#;#)#{#String#[#]#mapped#=#mapperImpl#.#mapFileName#(#String#.#valueOf#(#iter#.#next#(#)#)#)#;#for#(#int#m#=#0#;#mapped#!=#null#&&#m#<#mapped#.#length#;#++#m#)#{#ret#.#add#(#mapped#[#m#]#)#;#}#}#boolean#first#=#true#;#for#(#Iterator#mappedIter#=#ret#.#iterator#(#)#;#mappedIter#.#hasNext#(#)#;#)#{#String#elem#=#mapElement#(#(#String#)#mappedIter#.#next#(#)#)#;#// Apply the path prefix map#// Now convert the path and file separator characters from the#// current os to the target os.#if#(#!#first#)#{#rslt#.#append#(#pathSep#)#;#}#first#=#false#;#StringTokenizer#stDirectory#=#new#StringTokenizer#(#elem#,#fromDirSep#,#true#)#;#while#(#stDirectory#.#hasMoreTokens#(#)#)#{#String#token#=#stDirectory#.#nextToken#(#)#;#rslt#.#append#(#fromDirSep#.#equals#(#token#)#?#dirSep#:#token#)#;#}#}#// Place the result into the specified property,#// unless setonempty == false#if#(#setonempty#||#rslt#.#length#(#)#>#0#)#{#String#value#=#rslt#.#toString#(#)#;#if#(#property#==#null#)#{#log#(#value#)#;#}#else#{#log#(#"Set property "#+#property#+#" = "#+#value#,#Project#.#MSG_VERBOSE#)#;#getProject#(#)#.#setNewProperty#(#property#,#value#)#;#}#}#}#finally#{#path#=#savedPath#;#dirSep#=#savedDirSep#;#pathSep#=#savedPathSep#;#}#}##String#mapElement#(#String#elem#)#{#int#size#=#prefixMap#.#size#(#)#;#if#(#size#!=#0#)#{#// Iterate over the map entries and apply each one.#// Stop when one of the entries actually changes the element.#for#(#int#i#=#0#;#i#<#size#;#i#++#)#{#MapEntry#entry#=#(#MapEntry#)#prefixMap#.#elementAt#(#i#)#;#String#newElem#=#entry#.#apply#(#elem#)#;#// Note I'm using "!=" to see if we got a new object back from#// the apply method.#if#(#newElem#!=#elem#)#{#elem#=#newElem#;#break#;#// We applied one, so we're done#}#}#}#return#elem#;#}##void#addMapper#(#Mapper#mapper#)#{#if#(#this#.#mapper#!=#null#)#{#throw#new#BuildException#(#"Cannot define more than one mapper"#)#;#}#this#.#mapper#=#mapper#;#}##void#add#(#FileNameMapper#fileNameMapper#)#{#Mapper#m#=#new#Mapper#(#getProject#(#)#)#;#m#.#add#(#fileNameMapper#)#;#addMapper#(#m#)#;#}##void#validateSetup#(#)#throws#BuildException#{#if#(#path#==#null#)#{#throw#new#BuildException#(#"You must specify a path to convert"#)#;#}#// Determine the separator strings.  The dirsep and pathsep attributes#// override the targetOS settings.#String#dsep#=#File#.#separator#;#String#psep#=#File#.#pathSeparator#;#if#(#targetOS#!=#null#)#{#psep#=#targetWindows#?#";"#:#":"#;#dsep#=#targetWindows#?#"\\"#:#"/"#;#}#if#(#pathSep#!=#null#)#{#// override with pathsep=#psep#=#pathSep#;#}#if#(#dirSep#!=#null#)#{#// override with dirsep=#dsep#=#dirSep#;#}#pathSep#=#psep#;#dirSep#=#dsep#;#}##BuildException#noChildrenAllowed#(#)#{#return#new#BuildException#(#"You must not specify nested "#+#"elements when using the refid attribute."#)#;#}##