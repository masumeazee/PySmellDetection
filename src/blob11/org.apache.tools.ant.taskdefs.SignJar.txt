void#setSigfile#(#final#String#sigfile#)#{#this#.#sigfile#=#sigfile#;#}##void#setSignedjar#(#final#File#signedjar#)#{#this#.#signedjar#=#signedjar#;#}##void#setInternalsf#(#final#boolean#internalsf#)#{#this#.#internalsf#=#internalsf#;#}##void#setSectionsonly#(#final#boolean#sectionsonly#)#{#this#.#sectionsonly#=#sectionsonly#;#}##void#setLazy#(#final#boolean#lazy#)#{#this#.#lazy#=#lazy#;#}##void#setDestDir#(#File#destDir#)#{#this#.#destDir#=#destDir#;#}##void#add#(#FileNameMapper#newMapper#)#{#if#(#mapper#!=#null#)#{#throw#new#BuildException#(#ERROR_TOO_MANY_MAPPERS#)#;#}#mapper#=#newMapper#;#}##FileNameMapper#getMapper#(#)#{#return#mapper#;#}##String#getTsaurl#(#)#{#return#tsaurl#;#}##void#setTsaurl#(#String#tsaurl#)#{#this#.#tsaurl#=#tsaurl#;#}##String#getTsacert#(#)#{#return#tsacert#;#}##void#setTsacert#(#String#tsacert#)#{#this#.#tsacert#=#tsacert#;#}##void#setForce#(#boolean#b#)#{#force#=#b#;#}##boolean#isForce#(#)#{#return#force#;#}##void#execute#(#)#throws#BuildException#{#//validation logic#final#boolean#hasJar#=#jar#!=#null#;#final#boolean#hasSignedJar#=#signedjar#!=#null#;#final#boolean#hasDestDir#=#destDir#!=#null#;#final#boolean#hasMapper#=#mapper#!=#null#;#if#(#!#hasJar#&&#!#hasResources#(#)#)#{#throw#new#BuildException#(#ERROR_NO_SOURCE#)#;#}#if#(#null#==#alias#)#{#throw#new#BuildException#(#ERROR_NO_ALIAS#)#;#}#if#(#null#==#storepass#)#{#throw#new#BuildException#(#ERROR_NO_STOREPASS#)#;#}#if#(#hasDestDir#&&#hasSignedJar#)#{#throw#new#BuildException#(#ERROR_TODIR_AND_SIGNEDJAR#)#;#}#if#(#hasResources#(#)#&&#hasSignedJar#)#{#throw#new#BuildException#(#ERROR_SIGNEDJAR_AND_PATHS#)#;#}#//this isnt strictly needed, but by being fussy now,#//we can change implementation details later#if#(#!#hasDestDir#&&#hasMapper#)#{#throw#new#BuildException#(#ERROR_MAPPER_WITHOUT_DEST#)#;#}#beginExecution#(#)#;#try#{#//special case single jar handling with signedjar attribute set#if#(#hasJar#&&#hasSignedJar#)#{#// single jar processing#signOneJar#(#jar#,#signedjar#)#;#//return here.#return#;#}#//the rest of the method treats single jar like#//a nested path with one file#Path#sources#=#createUnifiedSourcePath#(#)#;#//set up our mapping policy#FileNameMapper#destMapper#;#if#(#hasMapper#)#{#destMapper#=#mapper#;#}#else#{#//no mapper? use the identity policy#destMapper#=#new#IdentityMapper#(#)#;#}#//at this point the paths are set up with lists of files,#//and the mapper is ready to map from source dirs to dest files#//now we iterate through every JAR giving source and dest names#// deal with the paths#Iterator#iter#=#sources#.#iterator#(#)#;#while#(#iter#.#hasNext#(#)#)#{#Resource#r#=#(#Resource#)#iter#.#next#(#)#;#FileResource#fr#=#ResourceUtils#.#asFileResource#(#(#FileProvider#)#r#.#as#(#FileProvider#.#class#)#)#;#//calculate our destination directory; it is either the destDir#//attribute, or the base dir of the fileset (for in situ updates)#File#toDir#=#hasDestDir#?#destDir#:#fr#.#getBaseDir#(#)#;#//determine the destination filename via the mapper#String#[#]#destFilenames#=#destMapper#.#mapFileName#(#fr#.#getName#(#)#)#;#if#(#destFilenames#==#null#||#destFilenames#.#length#!=#1#)#{#//we only like simple mappers.#throw#new#BuildException#(#ERROR_BAD_MAP#+#fr#.#getFile#(#)#)#;#}#File#destFile#=#new#File#(#toDir#,#destFilenames#[#0#]#)#;#signOneJar#(#fr#.#getFile#(#)#,#destFile#)#;#}#}#finally#{#endExecution#(#)#;#}#}##void#signOneJar#(#File#jarSource#,#File#jarTarget#)#throws#BuildException#{#File#targetFile#=#jarTarget#;#if#(#targetFile#==#null#)#{#targetFile#=#jarSource#;#}#if#(#isUpToDate#(#jarSource#,#targetFile#)#)#{#return#;#}#long#lastModified#=#jarSource#.#lastModified#(#)#;#final#ExecTask#cmd#=#createJarSigner#(#)#;#setCommonOptions#(#cmd#)#;#bindToKeystore#(#cmd#)#;#if#(#null#!=#sigfile#)#{#addValue#(#cmd#,#"-sigfile"#)#;#String#value#=#this#.#sigfile#;#addValue#(#cmd#,#value#)#;#}#//DO NOT SET THE -signedjar OPTION if source==dest#//unless you like fielding hotspot crash reports#if#(#!#jarSource#.#equals#(#targetFile#)#)#{#addValue#(#cmd#,#"-signedjar"#)#;#addValue#(#cmd#,#targetFile#.#getPath#(#)#)#;#}#if#(#internalsf#)#{#addValue#(#cmd#,#"-internalsf"#)#;#}#if#(#sectionsonly#)#{#addValue#(#cmd#,#"-sectionsonly"#)#;#}#//add -tsa operations if declared#addTimestampAuthorityCommands#(#cmd#)#;#//JAR source is required#addValue#(#cmd#,#jarSource#.#getPath#(#)#)#;#//alias is required for signing#addValue#(#cmd#,#alias#)#;#log#(#"Signing JAR: "#+#jarSource#.#getAbsolutePath#(#)#+#" to "#+#targetFile#.#getAbsolutePath#(#)#+#" as "#+#alias#)#;#cmd#.#execute#(#)#;#// restore the lastModified attribute#if#(#preserveLastModified#)#{#targetFile#.#setLastModified#(#lastModified#)#;#}#}##void#addTimestampAuthorityCommands#(#final#ExecTask#cmd#)#{#if#(#tsaurl#!=#null#)#{#addValue#(#cmd#,#"-tsa"#)#;#addValue#(#cmd#,#tsaurl#)#;#}#if#(#tsacert#!=#null#)#{#addValue#(#cmd#,#"-tsacert"#)#;#addValue#(#cmd#,#tsacert#)#;#}#}##boolean#isUpToDate#(#File#jarFile#,#File#signedjarFile#)#{#if#(#isForce#(#)#||#null#==#jarFile#||#!#jarFile#.#exists#(#)#)#{#//these are pathological cases, but retained in case somebody#//subclassed us.#return#false#;#}#//we normally compare destination with source#File#destFile#=#signedjarFile#;#if#(#destFile#==#null#)#{#//but if no dest is specified, compare source to source#destFile#=#jarFile#;#}#//if, by any means, the destfile and source match,#if#(#jarFile#.#equals#(#destFile#)#)#{#if#(#lazy#)#{#//we check the presence of signatures on lazy signing#return#isSigned#(#jarFile#)#;#}#//unsigned or non-lazy self signings are always false#return#false#;#}#//if they are different, the timestamps are used#return#FILE_UTILS#.#isUpToDate#(#jarFile#,#destFile#)#;#}##boolean#isSigned#(#File#file#)#{#try#{#return#IsSigned#.#isSigned#(#file#,#sigfile#==#null#?#alias#:#sigfile#)#;#}#catch#(#IOException#e#)#{#//just log this#log#(#e#.#toString#(#)#,#Project#.#MSG_VERBOSE#)#;#return#false#;#}#}##void#setPreserveLastModified#(#boolean#preserveLastModified#)#{#this#.#preserveLastModified#=#preserveLastModified#;#}##