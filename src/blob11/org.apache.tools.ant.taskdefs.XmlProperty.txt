void#init#(#)#{#super#.#init#(#)#;#xmlCatalog#.#setProject#(#getProject#(#)#)#;#}##EntityResolver#getEntityResolver#(#)#{#return#xmlCatalog#;#}##void#execute#(#)#throws#BuildException#{#Resource#r#=#getResource#(#)#;#if#(#r#==#null#)#{#throw#new#BuildException#(#"XmlProperty task requires a source resource"#)#;#}#try#{#log#(#"Loading "#+#src#,#Project#.#MSG_VERBOSE#)#;#if#(#r#.#isExists#(#)#)#{#DocumentBuilderFactory#factory#=#DocumentBuilderFactory#.#newInstance#(#)#;#factory#.#setValidating#(#validate#)#;#factory#.#setNamespaceAware#(#false#)#;#DocumentBuilder#builder#=#factory#.#newDocumentBuilder#(#)#;#builder#.#setEntityResolver#(#getEntityResolver#(#)#)#;#Document#document#=#null#;#FileProvider#fp#=#(#FileProvider#)#src#.#as#(#FileProvider#.#class#)#;#if#(#fp#!=#null#)#{#document#=#builder#.#parse#(#fp#.#getFile#(#)#)#;#}#else#{#document#=#builder#.#parse#(#src#.#getInputStream#(#)#)#;#}#Element#topElement#=#document#.#getDocumentElement#(#)#;#// Keep a hashtable of attributes added by this task.#// This task is allow to override its own properties#// but not other properties.  So we need to keep track#// of which properties we've added.#addedAttributes#=#new#Hashtable#(#)#;#if#(#keepRoot#)#{#addNodeRecursively#(#topElement#,#prefix#,#null#)#;#}#else#{#NodeList#topChildren#=#topElement#.#getChildNodes#(#)#;#int#numChildren#=#topChildren#.#getLength#(#)#;#for#(#int#i#=#0#;#i#<#numChildren#;#i#++#)#{#addNodeRecursively#(#topChildren#.#item#(#i#)#,#prefix#,#null#)#;#}#}#}#else#{#log#(#"Unable to find property resource: "#+#r#,#Project#.#MSG_VERBOSE#)#;#}#}#catch#(#SAXException#sxe#)#{#// Error generated during parsing#Exception#x#=#sxe#;#if#(#sxe#.#getException#(#)#!=#null#)#{#x#=#sxe#.#getException#(#)#;#}#throw#new#BuildException#(#"Failed to load "#+#src#,#x#)#;#}#catch#(#ParserConfigurationException#pce#)#{#// Parser with specified options can't be built#throw#new#BuildException#(#pce#)#;#}#catch#(#IOException#ioe#)#{#// I/O error#throw#new#BuildException#(#"Failed to load "#+#src#,#ioe#)#;#}#}##void#addNodeRecursively#(#Node#node#,#String#prefix#,#Object#container#)#{#// Set the prefix for this node to include its tag name.#String#nodePrefix#=#prefix#;#if#(#node#.#getNodeType#(#)#!=#Node#.#TEXT_NODE#)#{#if#(#prefix#.#trim#(#)#.#length#(#)#>#0#)#{#nodePrefix#+=#"."#;#}#nodePrefix#+=#node#.#getNodeName#(#)#;#}#// Pass the container to the processing of this node,#Object#nodeObject#=#processNode#(#node#,#nodePrefix#,#container#)#;#// now, iterate through children.#if#(#node#.#hasChildNodes#(#)#)#{#NodeList#nodeChildren#=#node#.#getChildNodes#(#)#;#int#numChildren#=#nodeChildren#.#getLength#(#)#;#for#(#int#i#=#0#;#i#<#numChildren#;#i#++#)#{#// For each child, pass the object added by#// processNode to its children -- in other word, each#// object can pass information along to its children.#addNodeRecursively#(#nodeChildren#.#item#(#i#)#,#nodePrefix#,#nodeObject#)#;#}#}#}##void#addNodeRecursively#(#org#.#w3c#.#dom#.#Node#node#,#String#prefix#)#{#addNodeRecursively#(#node#,#prefix#,#null#)#;#}##Object#processNode#(#Node#node#,#String#prefix#,#Object#container#)#{#// Parse the attribute(s) and text of this node, adding#// properties for each.#// if the "path" attribute is specified, then return the created path#// which will be passed to the children of this node.#Object#addedPath#=#null#;#// The value of an id attribute of this node.#String#id#=#null#;#if#(#node#.#hasAttributes#(#)#)#{#NamedNodeMap#nodeAttributes#=#node#.#getAttributes#(#)#;#// Is there an id attribute?#Node#idNode#=#nodeAttributes#.#getNamedItem#(#ID#)#;#id#=#semanticAttributes#&&#idNode#!=#null#?#idNode#.#getNodeValue#(#)#:#null#;#// Now, iterate through the attributes adding them.#for#(#int#i#=#0#;#i#<#nodeAttributes#.#getLength#(#)#;#i#++#)#{#Node#attributeNode#=#nodeAttributes#.#item#(#i#)#;#if#(#!#semanticAttributes#)#{#String#attributeName#=#getAttributeName#(#attributeNode#)#;#String#attributeValue#=#getAttributeValue#(#attributeNode#)#;#addProperty#(#prefix#+#attributeName#,#attributeValue#,#null#)#;#}#else#{#String#nodeName#=#attributeNode#.#getNodeName#(#)#;#String#attributeValue#=#getAttributeValue#(#attributeNode#)#;#Path#containingPath#=#(#(#container#!=#null#)#&&#(#container#instanceof#Path#)#)#?#(#Path#)#container#:#null#;#/*
                     * The main conditional logic -- if the attribute
                     * is somehow "special" (i.e., it has known
                     * semantic meaning) then deal with it
                     * appropriately.
                     */#if#(#nodeName#.#equals#(#ID#)#)#{#// ID has already been found above.#continue#;#}#if#(#containingPath#!=#null#&&#nodeName#.#equals#(#PATH#)#)#{#// A "path" attribute for a node within a Path object.#containingPath#.#setPath#(#attributeValue#)#;#}#else#if#(#container#instanceof#Path#&&#nodeName#.#equals#(#REF_ID#)#)#{#// A "refid" attribute for a node within a Path object.#containingPath#.#setPath#(#attributeValue#)#;#}#else#if#(#container#instanceof#Path#&&#nodeName#.#equals#(#LOCATION#)#)#{#// A "location" attribute for a node within a#// Path object.#containingPath#.#setLocation#(#resolveFile#(#attributeValue#)#)#;#}#else#if#(#nodeName#.#equals#(#PATHID#)#)#{#// A node identifying a new path#if#(#container#!=#null#)#{#throw#new#BuildException#(#"XmlProperty does not support nested paths"#)#;#}#addedPath#=#new#Path#(#getProject#(#)#)#;#getProject#(#)#.#addReference#(#attributeValue#,#addedPath#)#;#}#else#{#// An arbitrary attribute.#String#attributeName#=#getAttributeName#(#attributeNode#)#;#addProperty#(#prefix#+#attributeName#,#attributeValue#,#id#)#;#}#}#}#}#String#nodeText#=#null#;#boolean#emptyNode#=#false#;#boolean#semanticEmptyOverride#=#false#;#if#(#node#.#getNodeType#(#)#==#Node#.#ELEMENT_NODE#&&#semanticAttributes#&&#node#.#hasAttributes#(#)#&&#(#node#.#getAttributes#(#)#.#getNamedItem#(#VALUE#)#!=#null#||#node#.#getAttributes#(#)#.#getNamedItem#(#LOCATION#)#!=#null#||#node#.#getAttributes#(#)#.#getNamedItem#(#REF_ID#)#!=#null#||#node#.#getAttributes#(#)#.#getNamedItem#(#PATH#)#!=#null#||#node#.#getAttributes#(#)#.#getNamedItem#(#PATHID#)#!=#null#)#)#{#semanticEmptyOverride#=#true#;#}#if#(#node#.#getNodeType#(#)#==#Node#.#TEXT_NODE#)#{#// For the text node, add a property.#nodeText#=#getAttributeValue#(#node#)#;#}#else#if#(#node#.#getNodeType#(#)#==#Node#.#ELEMENT_NODE#&&#node#.#getChildNodes#(#)#.#getLength#(#)#==#1#&&#node#.#getFirstChild#(#)#.#getNodeType#(#)#==#Node#.#CDATA_SECTION_NODE#)#{#nodeText#=#node#.#getFirstChild#(#)#.#getNodeValue#(#)#;#if#(#""#.#equals#(#nodeText#)#&&#!#semanticEmptyOverride#)#{#emptyNode#=#true#;#}#}#else#if#(#node#.#getNodeType#(#)#==#Node#.#ELEMENT_NODE#&&#node#.#getChildNodes#(#)#.#getLength#(#)#==#0#&&#!#semanticEmptyOverride#)#{#nodeText#=#""#;#emptyNode#=#true#;#}#else#if#(#node#.#getNodeType#(#)#==#Node#.#ELEMENT_NODE#&&#node#.#getChildNodes#(#)#.#getLength#(#)#==#1#&&#node#.#getFirstChild#(#)#.#getNodeType#(#)#==#Node#.#TEXT_NODE#&&#""#.#equals#(#node#.#getFirstChild#(#)#.#getNodeValue#(#)#)#&&#!#semanticEmptyOverride#)#{#nodeText#=#""#;#emptyNode#=#true#;#}#if#(#nodeText#!=#null#)#{#// If the containing object was a String, then use it as the ID.#if#(#semanticAttributes#&&#id#==#null#&&#container#instanceof#String#)#{#id#=#(#String#)#container#;#}#if#(#nodeText#.#trim#(#)#.#length#(#)#!=#0#||#emptyNode#)#{#addProperty#(#prefix#,#nodeText#,#id#)#;#}#}#// Return the Path we added or the ID of this node for#// children to reference if needed.  Path objects are#// definitely used by child path elements, and ID may be used#// for a child text node.#return#(#addedPath#!=#null#?#addedPath#:#id#)#;#}##void#addProperty#(#String#name#,#String#value#,#String#id#)#{#String#msg#=#name#+#":"#+#value#;#if#(#id#!=#null#)#{#msg#+=#(#"(id="#+#id#+#")"#)#;#}#log#(#msg#,#Project#.#MSG_DEBUG#)#;#if#(#addedAttributes#.#containsKey#(#name#)#)#{#// If this attribute was added by this task, then#// we append this value to the existing value.#// We use the setProperty method which will#// forcibly override the property if it already exists.#// We need to put these properties into the project#// when we read them, though (instead of keeping them#// outside of the project and batch adding them at the end)#// to allow other properties to reference them.#value#=#(#String#)#addedAttributes#.#get#(#name#)#+#getDelimiter#(#)#+#value#;#getProject#(#)#.#setProperty#(#name#,#value#)#;#addedAttributes#.#put#(#name#,#value#)#;#}#else#if#(#getProject#(#)#.#getProperty#(#name#)#==#null#)#{#getProject#(#)#.#setNewProperty#(#name#,#value#)#;#addedAttributes#.#put#(#name#,#value#)#;#}#else#{#log#(#"Override ignored for property "#+#name#,#Project#.#MSG_VERBOSE#)#;#}#if#(#id#!=#null#)#{#getProject#(#)#.#addReference#(#id#,#value#)#;#}#}##String#getAttributeName#(#Node#attributeNode#)#{#String#attributeName#=#attributeNode#.#getNodeName#(#)#;#if#(#semanticAttributes#)#{#// Never include the "refid" attribute as part of the#// attribute name.#if#(#attributeName#.#equals#(#REF_ID#)#)#{#return#""#;#}#// Otherwise, return it appended unless property to hide it is set.#if#(#!#isSemanticAttribute#(#attributeName#)#||#includeSemanticAttribute#)#{#return#"."#+#attributeName#;#}#return#""#;#}#return#collapseAttributes#?#"."#+#attributeName#:#"("#+#attributeName#+#")"#;#}##boolean#isSemanticAttribute#(#String#attributeName#)#{#for#(#int#i#=#0#;#i#<#ATTRIBUTES#.#length#;#i#++#)#{#if#(#attributeName#.#equals#(#ATTRIBUTES#[#i#]#)#)#{#return#true#;#}#}#return#false#;#}##String#getAttributeValue#(#Node#attributeNode#)#{#String#nodeValue#=#attributeNode#.#getNodeValue#(#)#.#trim#(#)#;#if#(#semanticAttributes#)#{#String#attributeName#=#attributeNode#.#getNodeName#(#)#;#nodeValue#=#getProject#(#)#.#replaceProperties#(#nodeValue#)#;#if#(#attributeName#.#equals#(#LOCATION#)#)#{#File#f#=#resolveFile#(#nodeValue#)#;#return#f#.#getPath#(#)#;#}#if#(#attributeName#.#equals#(#REF_ID#)#)#{#Object#ref#=#getProject#(#)#.#getReference#(#nodeValue#)#;#if#(#ref#!=#null#)#{#return#ref#.#toString#(#)#;#}#}#}#return#nodeValue#;#}##void#setFile#(#File#src#)#{#setSrcResource#(#new#FileResource#(#src#)#)#;#}##void#setSrcResource#(#Resource#src#)#{#if#(#src#.#isDirectory#(#)#)#{#throw#new#BuildException#(#"the source can't be a directory"#)#;#}#if#(#src#.#as#(#FileProvider#.#class#)#!=#null#||#supportsNonFileResources#(#)#)#{#this#.#src#=#src#;#}#else#{#throw#new#BuildException#(#"Only FileSystem resources are supported."#)#;#}#}##void#addConfigured#(#ResourceCollection#a#)#{#if#(#a#.#size#(#)#!=#1#)#{#throw#new#BuildException#(#"only single argument resource collections are supported as archives"#)#;#}#setSrcResource#(#(#Resource#)#a#.#iterator#(#)#.#next#(#)#)#;#}##void#setPrefix#(#String#prefix#)#{#this#.#prefix#=#prefix#.#trim#(#)#;#}##void#setKeeproot#(#boolean#keepRoot#)#{#this#.#keepRoot#=#keepRoot#;#}##void#setValidate#(#boolean#validate#)#{#this#.#validate#=#validate#;#}##void#setCollapseAttributes#(#boolean#collapseAttributes#)#{#this#.#collapseAttributes#=#collapseAttributes#;#}##void#setSemanticAttributes#(#boolean#semanticAttributes#)#{#this#.#semanticAttributes#=#semanticAttributes#;#}##void#setRootDirectory#(#File#rootDirectory#)#{#this#.#rootDirectory#=#rootDirectory#;#}##void#setIncludeSemanticAttribute#(#boolean#includeSemanticAttribute#)#{#this#.#includeSemanticAttribute#=#includeSemanticAttribute#;#}##void#addConfiguredXMLCatalog#(#XMLCatalog#catalog#)#{#xmlCatalog#.#addConfiguredXMLCatalog#(#catalog#)#;#}##File#getFile#(#)#{#FileProvider#fp#=#(#FileProvider#)#src#.#as#(#FileProvider#.#class#)#;#return#fp#!=#null#?#fp#.#getFile#(#)#:#null#;#}##Resource#getResource#(#)#{#// delegate this way around to support subclasses that#// overwrite getFile#File#f#=#getFile#(#)#;#FileProvider#fp#=#(#FileProvider#)#src#.#as#(#FileProvider#.#class#)#;#return#f#==#null#?#src#:#fp#!=#null#&&#fp#.#getFile#(#)#.#equals#(#f#)#?#src#:#new#FileResource#(#f#)#;#}##String#getPrefix#(#)#{#return#this#.#prefix#;#}##boolean#getKeeproot#(#)#{#return#this#.#keepRoot#;#}##boolean#getValidate#(#)#{#return#this#.#validate#;#}##boolean#getCollapseAttributes#(#)#{#return#this#.#collapseAttributes#;#}##boolean#getSemanticAttributes#(#)#{#return#this#.#semanticAttributes#;#}##File#getRootDirectory#(#)#{#return#this#.#rootDirectory#;#}##boolean#getIncludeSementicAttribute#(#)#{#return#this#.#includeSemanticAttribute#;#}##File#resolveFile#(#String#fileName#)#{#return#FILE_UTILS#.#resolveFile#(#rootDirectory#==#null#?#getProject#(#)#.#getBaseDir#(#)#:#rootDirectory#,#fileName#)#;#}##boolean#supportsNonFileResources#(#)#{#return#getClass#(#)#.#equals#(#XmlProperty#.#class#)#;#}##String#getDelimiter#(#)#{#return#delimiter#;#}##void#setDelimiter#(#String#delimiter#)#{#this#.#delimiter#=#delimiter#;#}##