Vector#getElements#(#)#{#return#getRef#(#)#.#elements#;#}##Path#getClasspath#(#)#{#return#getRef#(#)#.#classpath#;#}##Path#createClasspath#(#)#{#if#(#isReference#(#)#)#{#throw#noChildrenAllowed#(#)#;#}#if#(#this#.#classpath#==#null#)#{#this#.#classpath#=#new#Path#(#getProject#(#)#)#;#}#setChecked#(#false#)#;#return#this#.#classpath#.#createPath#(#)#;#}##void#setClasspath#(#Path#classpath#)#{#if#(#isReference#(#)#)#{#throw#tooManyAttributes#(#)#;#}#if#(#this#.#classpath#==#null#)#{#this#.#classpath#=#classpath#;#}#else#{#this#.#classpath#.#append#(#classpath#)#;#}#setChecked#(#false#)#;#}##void#setClasspathRef#(#Reference#r#)#{#if#(#isReference#(#)#)#{#throw#tooManyAttributes#(#)#;#}#createClasspath#(#)#.#setRefid#(#r#)#;#setChecked#(#false#)#;#}##Path#createCatalogPath#(#)#{#if#(#isReference#(#)#)#{#throw#noChildrenAllowed#(#)#;#}#if#(#this#.#catalogPath#==#null#)#{#this#.#catalogPath#=#new#Path#(#getProject#(#)#)#;#}#setChecked#(#false#)#;#return#this#.#catalogPath#.#createPath#(#)#;#}##void#setCatalogPathRef#(#Reference#r#)#{#if#(#isReference#(#)#)#{#throw#tooManyAttributes#(#)#;#}#createCatalogPath#(#)#.#setRefid#(#r#)#;#setChecked#(#false#)#;#}##Path#getCatalogPath#(#)#{#return#getRef#(#)#.#catalogPath#;#}##void#addDTD#(#ResourceLocation#dtd#)#throws#BuildException#{#if#(#isReference#(#)#)#{#throw#noChildrenAllowed#(#)#;#}#getElements#(#)#.#addElement#(#dtd#)#;#setChecked#(#false#)#;#}##void#addEntity#(#ResourceLocation#entity#)#throws#BuildException#{#addDTD#(#entity#)#;#}##void#addConfiguredXMLCatalog#(#XMLCatalog#catalog#)#{#if#(#isReference#(#)#)#{#throw#noChildrenAllowed#(#)#;#}#// Add all nested elements to our catalog#Vector#newElements#=#catalog#.#getElements#(#)#;#Vector#ourElements#=#getElements#(#)#;#Enumeration#e#=#newElements#.#elements#(#)#;#while#(#e#.#hasMoreElements#(#)#)#{#ourElements#.#addElement#(#e#.#nextElement#(#)#)#;#}#// Append the classpath of the nested catalog#Path#nestedClasspath#=#catalog#.#getClasspath#(#)#;#createClasspath#(#)#.#append#(#nestedClasspath#)#;#// Append the catalog path of the nested catalog#Path#nestedCatalogPath#=#catalog#.#getCatalogPath#(#)#;#createCatalogPath#(#)#.#append#(#nestedCatalogPath#)#;#setChecked#(#false#)#;#}##void#setRefid#(#Reference#r#)#throws#BuildException#{#if#(#!#elements#.#isEmpty#(#)#)#{#throw#tooManyAttributes#(#)#;#}#super#.#setRefid#(#r#)#;#}##InputSource#resolveEntity#(#String#publicId#,#String#systemId#)#throws#SAXException#,#IOException#{#if#(#isReference#(#)#)#{#return#getRef#(#)#.#resolveEntity#(#publicId#,#systemId#)#;#}#dieOnCircularReference#(#)#;#log#(#"resolveEntity: '"#+#publicId#+#"': '"#+#systemId#+#"'"#,#Project#.#MSG_DEBUG#)#;#InputSource#inputSource#=#getCatalogResolver#(#)#.#resolveEntity#(#publicId#,#systemId#)#;#if#(#inputSource#==#null#)#{#log#(#"No matching catalog entry found, parser will use: '"#+#systemId#+#"'"#,#Project#.#MSG_DEBUG#)#;#}#return#inputSource#;#}##Source#resolve#(#String#href#,#String#base#)#throws#TransformerException#{#if#(#isReference#(#)#)#{#return#getRef#(#)#.#resolve#(#href#,#base#)#;#}#dieOnCircularReference#(#)#;#SAXSource#source#=#null#;#String#uri#=#removeFragment#(#href#)#;#log#(#"resolve: '"#+#uri#+#"' with base: '"#+#base#+#"'"#,#Project#.#MSG_DEBUG#)#;#source#=#(#SAXSource#)#getCatalogResolver#(#)#.#resolve#(#uri#,#base#)#;#if#(#source#==#null#)#{#log#(#"No matching catalog entry found, parser will use: '"#+#href#+#"'"#,#Project#.#MSG_DEBUG#)#;#//#// Cannot return a null source, because we have to call#// setEntityResolver (see setEntityResolver javadoc comment)#//#source#=#new#SAXSource#(#)#;#URL#baseURL#=#null#;#try#{#if#(#base#==#null#)#{#baseURL#=#FILE_UTILS#.#getFileURL#(#getProject#(#)#.#getBaseDir#(#)#)#;#}#else#{#baseURL#=#new#URL#(#base#)#;#}#URL#url#=#(#uri#.#length#(#)#==#0#?#baseURL#:#new#URL#(#baseURL#,#uri#)#)#;#source#.#setInputSource#(#new#InputSource#(#url#.#toString#(#)#)#)#;#}#catch#(#MalformedURLException#ex#)#{#// At this point we are probably in failure mode, but#// try to use the bare URI as a last gasp#source#.#setInputSource#(#new#InputSource#(#uri#)#)#;#}#}#setEntityResolver#(#source#)#;#return#source#;#}##void#dieOnCircularReference#(#Stack#stk#,#Project#p#)#throws#BuildException#{#if#(#isChecked#(#)#)#{#return#;#}#if#(#isReference#(#)#)#{#super#.#dieOnCircularReference#(#stk#,#p#)#;#}#else#{#if#(#classpath#!=#null#)#{#pushAndInvokeCircularReferenceCheck#(#classpath#,#stk#,#p#)#;#}#if#(#catalogPath#!=#null#)#{#pushAndInvokeCircularReferenceCheck#(#catalogPath#,#stk#,#p#)#;#}#setChecked#(#true#)#;#}#}##XMLCatalog#getRef#(#)#{#if#(#!#isReference#(#)#)#{#return#this#;#}#return#(#XMLCatalog#)#getCheckedRef#(#XMLCatalog#.#class#,#"xmlcatalog"#)#;#}##CatalogResolver#getCatalogResolver#(#)#{#if#(#catalogResolver#==#null#)#{#AntClassLoader#loader#=#null#;#// Memory-Leak in line below#loader#=#getProject#(#)#.#createClassLoader#(#Path#.#systemClasspath#)#;#try#{#Class#clazz#=#Class#.#forName#(#APACHE_RESOLVER#,#true#,#loader#)#;#// The Apache resolver is present - Need to check if it can#// be seen by the catalog resolver class. Start by getting#// the actual loader#ClassLoader#apacheResolverLoader#=#clazz#.#getClassLoader#(#)#;#// load the base class through this loader.#Class#baseResolverClass#=#Class#.#forName#(#CATALOG_RESOLVER#,#true#,#apacheResolverLoader#)#;#// and find its actual loader#ClassLoader#baseResolverLoader#=#baseResolverClass#.#getClassLoader#(#)#;#// We have the loader which is being used to load the#// CatalogResolver. Can it see the ApacheResolver? The#// base resolver will only be able to create the ApacheResolver#// if it can see it - doesn't use the context loader.#clazz#=#Class#.#forName#(#APACHE_RESOLVER#,#true#,#baseResolverLoader#)#;#Object#obj#=#clazz#.#newInstance#(#)#;#//#// Success!  The xml-commons resolver library is#// available, so use it.#//#catalogResolver#=#new#ExternalResolver#(#clazz#,#obj#)#;#}#catch#(#Throwable#ex#)#{#//#// The xml-commons resolver library is not#// available, so we can't use it.#//#catalogResolver#=#new#InternalResolver#(#)#;#if#(#getCatalogPath#(#)#!=#null#&&#getCatalogPath#(#)#.#list#(#)#.#length#!=#0#)#{#log#(#"Warning: XML resolver not found; external catalogs"#+#" will be ignored"#,#Project#.#MSG_WARN#)#;#}#log#(#"Failed to load Apache resolver: "#+#ex#,#Project#.#MSG_DEBUG#)#;#}#}#return#catalogResolver#;#}##void#setEntityResolver#(#SAXSource#source#)#throws#TransformerException#{#XMLReader#reader#=#source#.#getXMLReader#(#)#;#if#(#reader#==#null#)#{#SAXParserFactory#spFactory#=#SAXParserFactory#.#newInstance#(#)#;#spFactory#.#setNamespaceAware#(#true#)#;#try#{#reader#=#spFactory#.#newSAXParser#(#)#.#getXMLReader#(#)#;#}#catch#(#ParserConfigurationException#ex#)#{#throw#new#TransformerException#(#ex#)#;#}#catch#(#SAXException#ex#)#{#throw#new#TransformerException#(#ex#)#;#}#}#reader#.#setEntityResolver#(#this#)#;#source#.#setXMLReader#(#reader#)#;#}##ResourceLocation#findMatchingEntry#(#String#publicId#)#{#Enumeration#e#=#getElements#(#)#.#elements#(#)#;#ResourceLocation#element#=#null#;#while#(#e#.#hasMoreElements#(#)#)#{#Object#o#=#e#.#nextElement#(#)#;#if#(#o#instanceof#ResourceLocation#)#{#element#=#(#ResourceLocation#)#o#;#if#(#element#.#getPublicId#(#)#.#equals#(#publicId#)#)#{#return#element#;#}#}#}#return#null#;#}##String#removeFragment#(#String#uri#)#{#String#result#=#uri#;#int#hashPos#=#uri#.#indexOf#(#"#"#)#;#if#(#hashPos#>=#0#)#{#result#=#uri#.#substring#(#0#,#hashPos#)#;#}#return#result#;#}##InputSource#filesystemLookup#(#ResourceLocation#matchingEntry#)#{#String#uri#=#matchingEntry#.#getLocation#(#)#;#// the following line seems to be necessary on Windows under JDK 1.2#uri#=#uri#.#replace#(#File#.#separatorChar#,#'/'#)#;#URL#baseURL#=#null#;#//#// The ResourceLocation may specify a relative path for its#// location attribute.  This is resolved using the appropriate#// base.#//#if#(#matchingEntry#.#getBase#(#)#!=#null#)#{#baseURL#=#matchingEntry#.#getBase#(#)#;#}#else#{#try#{#baseURL#=#FILE_UTILS#.#getFileURL#(#getProject#(#)#.#getBaseDir#(#)#)#;#}#catch#(#MalformedURLException#ex#)#{#throw#new#BuildException#(#"Project basedir cannot be converted to a URL"#)#;#}#}#InputSource#source#=#null#;#URL#url#=#null#;#try#{#url#=#new#URL#(#baseURL#,#uri#)#;#}#catch#(#MalformedURLException#ex#)#{#// this processing is useful under Windows when the location of the DTD#// has been given as an absolute path#// see Bugzilla Report 23913#File#testFile#=#new#File#(#uri#)#;#if#(#testFile#.#exists#(#)#&&#testFile#.#canRead#(#)#)#{#log#(#"uri : '"#+#uri#+#"' matches a readable file"#,#Project#.#MSG_DEBUG#)#;#try#{#url#=#FILE_UTILS#.#getFileURL#(#testFile#)#;#}#catch#(#MalformedURLException#ex1#)#{#throw#new#BuildException#(#"could not find an URL for :"#+#testFile#.#getAbsolutePath#(#)#)#;#}#}#else#{#log#(#"uri : '"#+#uri#+#"' does not match a readable file"#,#Project#.#MSG_DEBUG#)#;#}#}#if#(#url#!=#null#&&#url#.#getProtocol#(#)#.#equals#(#"file"#)#)#{#String#fileName#=#FILE_UTILS#.#fromURI#(#url#.#toString#(#)#)#;#if#(#fileName#!=#null#)#{#log#(#"fileName "#+#fileName#,#Project#.#MSG_DEBUG#)#;#File#resFile#=#new#File#(#fileName#)#;#if#(#resFile#.#exists#(#)#&&#resFile#.#canRead#(#)#)#{#try#{#source#=#new#InputSource#(#new#FileInputStream#(#resFile#)#)#;#String#sysid#=#JAXPUtils#.#getSystemId#(#resFile#)#;#source#.#setSystemId#(#sysid#)#;#log#(#"catalog entry matched a readable file: '"#+#sysid#+#"'"#,#Project#.#MSG_DEBUG#)#;#}#catch#(#IOException#ex#)#{#// ignore#}#}#}#}#return#source#;#}##InputSource#classpathLookup#(#ResourceLocation#matchingEntry#)#{#InputSource#source#=#null#;#AntClassLoader#loader#=#null#;#Path#cp#=#classpath#;#if#(#cp#!=#null#)#{#cp#=#classpath#.#concatSystemClasspath#(#"ignore"#)#;#}#else#{#cp#=#(#new#Path#(#getProject#(#)#)#)#.#concatSystemClasspath#(#"last"#)#;#}#loader#=#getProject#(#)#.#createClassLoader#(#cp#)#;#//#// for classpath lookup we ignore the base directory#//#InputStream#is#=#loader#.#getResourceAsStream#(#matchingEntry#.#getLocation#(#)#)#;#if#(#is#!=#null#)#{#source#=#new#InputSource#(#is#)#;#URL#entryURL#=#loader#.#getResource#(#matchingEntry#.#getLocation#(#)#)#;#String#sysid#=#entryURL#.#toExternalForm#(#)#;#source#.#setSystemId#(#sysid#)#;#log#(#"catalog entry matched a resource in the classpath: '"#+#sysid#+#"'"#,#Project#.#MSG_DEBUG#)#;#}#return#source#;#}##InputSource#urlLookup#(#ResourceLocation#matchingEntry#)#{#String#uri#=#matchingEntry#.#getLocation#(#)#;#URL#baseURL#=#null#;#//#// The ResourceLocation may specify a relative url for its#// location attribute.  This is resolved using the appropriate#// base.#//#if#(#matchingEntry#.#getBase#(#)#!=#null#)#{#baseURL#=#matchingEntry#.#getBase#(#)#;#}#else#{#try#{#baseURL#=#FILE_UTILS#.#getFileURL#(#getProject#(#)#.#getBaseDir#(#)#)#;#}#catch#(#MalformedURLException#ex#)#{#throw#new#BuildException#(#"Project basedir cannot be converted to a URL"#)#;#}#}#InputSource#source#=#null#;#URL#url#=#null#;#try#{#url#=#new#URL#(#baseURL#,#uri#)#;#}#catch#(#MalformedURLException#ex#)#{#// ignore#}#if#(#url#!=#null#)#{#try#{#InputStream#is#=#url#.#openStream#(#)#;#if#(#is#!=#null#)#{#source#=#new#InputSource#(#is#)#;#String#sysid#=#url#.#toExternalForm#(#)#;#source#.#setSystemId#(#sysid#)#;#log#(#"catalog entry matched as a URL: '"#+#sysid#+#"'"#,#Project#.#MSG_DEBUG#)#;#}#}#catch#(#IOException#ex#)#{#// ignore#}#}#return#source#;#}##InputSource#resolveEntity#(#String#publicId#,#String#systemId#)#{#InputSource#result#=#null#;#ResourceLocation#matchingEntry#=#findMatchingEntry#(#publicId#)#;#if#(#matchingEntry#!=#null#)#{#log#(#"Matching catalog entry found for publicId: '"#+#matchingEntry#.#getPublicId#(#)#+#"' location: '"#+#matchingEntry#.#getLocation#(#)#+#"'"#,#Project#.#MSG_DEBUG#)#;#result#=#filesystemLookup#(#matchingEntry#)#;#if#(#result#==#null#)#{#result#=#classpathLookup#(#matchingEntry#)#;#}#if#(#result#==#null#)#{#result#=#urlLookup#(#matchingEntry#)#;#}#}#return#result#;#}##Source#resolve#(#String#href#,#String#base#)#throws#TransformerException#{#SAXSource#result#=#null#;#InputSource#source#=#null#;#ResourceLocation#matchingEntry#=#findMatchingEntry#(#href#)#;#if#(#matchingEntry#!=#null#)#{#log#(#"Matching catalog entry found for uri: '"#+#matchingEntry#.#getPublicId#(#)#+#"' location: '"#+#matchingEntry#.#getLocation#(#)#+#"'"#,#Project#.#MSG_DEBUG#)#;#//#// Use the passed in base in preference to the base#// from matchingEntry, which is either null or the#// directory in which the external catalog file from#// which it was obtained is located.  We make a copy#// so matchingEntry's original base is untouched.#//#// This is the standard behavior as per my reading of#// the JAXP and XML Catalog specs.  CKS 11/7/2002#//#ResourceLocation#entryCopy#=#matchingEntry#;#if#(#base#!=#null#)#{#try#{#URL#baseURL#=#new#URL#(#base#)#;#entryCopy#=#new#ResourceLocation#(#)#;#entryCopy#.#setBase#(#baseURL#)#;#}#catch#(#MalformedURLException#ex#)#{#// ignore#}#}#entryCopy#.#setPublicId#(#matchingEntry#.#getPublicId#(#)#)#;#entryCopy#.#setLocation#(#matchingEntry#.#getLocation#(#)#)#;#source#=#filesystemLookup#(#entryCopy#)#;#if#(#source#==#null#)#{#source#=#classpathLookup#(#entryCopy#)#;#}#if#(#source#==#null#)#{#source#=#urlLookup#(#entryCopy#)#;#}#if#(#source#!=#null#)#{#result#=#new#SAXSource#(#source#)#;#}#}#return#result#;#}##InputSource#resolveEntity#(#String#publicId#,#String#systemId#)#{#InputSource#result#=#null#;#processExternalCatalogs#(#)#;#ResourceLocation#matchingEntry#=#findMatchingEntry#(#publicId#)#;#if#(#matchingEntry#!=#null#)#{#log#(#"Matching catalog entry found for publicId: '"#+#matchingEntry#.#getPublicId#(#)#+#"' location: '"#+#matchingEntry#.#getLocation#(#)#+#"'"#,#Project#.#MSG_DEBUG#)#;#result#=#filesystemLookup#(#matchingEntry#)#;#if#(#result#==#null#)#{#result#=#classpathLookup#(#matchingEntry#)#;#}#if#(#result#==#null#)#{#try#{#result#=#(#InputSource#)#resolveEntity#.#invoke#(#resolverImpl#,#new#Object#[#]#{#publicId#,#systemId#}#)#;#}#catch#(#Exception#ex#)#{#throw#new#BuildException#(#ex#)#;#}#}#}#else#{#//#// We didn't match a ResourceLocation, but since we#// only support PUBLIC and URI entry types internally,#// it is still possible that there is another entry in#// an external catalog that will match.  We call#// Apache resolver's resolveEntity method to cover#// this possibility.#//#try#{#result#=#(#InputSource#)#resolveEntity#.#invoke#(#resolverImpl#,#new#Object#[#]#{#publicId#,#systemId#}#)#;#}#catch#(#Exception#ex#)#{#throw#new#BuildException#(#ex#)#;#}#}#return#result#;#}##Source#resolve#(#String#href#,#String#base#)#throws#TransformerException#{#SAXSource#result#=#null#;#InputSource#source#=#null#;#processExternalCatalogs#(#)#;#ResourceLocation#matchingEntry#=#findMatchingEntry#(#href#)#;#if#(#matchingEntry#!=#null#)#{#log#(#"Matching catalog entry found for uri: '"#+#matchingEntry#.#getPublicId#(#)#+#"' location: '"#+#matchingEntry#.#getLocation#(#)#+#"'"#,#Project#.#MSG_DEBUG#)#;#//#// Use the passed in base in preference to the base#// from matchingEntry, which is either null or the#// directory in which the external catalog file from#// which it was obtained is located.  We make a copy#// so matchingEntry's original base is untouched.  Of#// course, if there is no base, no need to make a#// copy...#//#// This is the standard behavior as per my reading of#// the JAXP and XML Catalog specs.  CKS 11/7/2002#//#ResourceLocation#entryCopy#=#matchingEntry#;#if#(#base#!=#null#)#{#try#{#URL#baseURL#=#new#URL#(#base#)#;#entryCopy#=#new#ResourceLocation#(#)#;#entryCopy#.#setBase#(#baseURL#)#;#}#catch#(#MalformedURLException#ex#)#{#// ignore#}#}#entryCopy#.#setPublicId#(#matchingEntry#.#getPublicId#(#)#)#;#entryCopy#.#setLocation#(#matchingEntry#.#getLocation#(#)#)#;#source#=#filesystemLookup#(#entryCopy#)#;#if#(#source#==#null#)#{#source#=#classpathLookup#(#entryCopy#)#;#}#if#(#source#!=#null#)#{#result#=#new#SAXSource#(#source#)#;#}#else#{#try#{#result#=#(#SAXSource#)#resolve#.#invoke#(#resolverImpl#,#new#Object#[#]#{#href#,#base#}#)#;#}#catch#(#Exception#ex#)#{#throw#new#BuildException#(#ex#)#;#}#}#}#else#{#//#// We didn't match a ResourceLocation, but since we#// only support PUBLIC and URI entry types internally,#// it is still possible that there is another entry in#// an external catalog that will match.  We call#// Apache resolver's resolveEntity method to cover#// this possibility.#//#try#{#result#=#(#SAXSource#)#resolve#.#invoke#(#resolverImpl#,#new#Object#[#]#{#href#,#base#}#)#;#}#catch#(#Exception#ex#)#{#throw#new#BuildException#(#ex#)#;#}#}#return#result#;#}##void#processExternalCatalogs#(#)#{#if#(#!#externalCatalogsProcessed#)#{#try#{#setXMLCatalog#.#invoke#(#resolverImpl#,#new#Object#[#]#{#XMLCatalog#.#this#}#)#;#}#catch#(#Exception#ex#)#{#throw#new#BuildException#(#ex#)#;#}#// Parse each catalog listed in nested <catalogpath> elements#Path#catPath#=#getCatalogPath#(#)#;#if#(#catPath#!=#null#)#{#log#(#"Using catalogpath '"#+#getCatalogPath#(#)#+#"'"#,#Project#.#MSG_DEBUG#)#;#String#[#]#catPathList#=#getCatalogPath#(#)#.#list#(#)#;#for#(#int#i#=#0#;#i#<#catPathList#.#length#;#i#++#)#{#File#catFile#=#new#File#(#catPathList#[#i#]#)#;#log#(#"Parsing "#+#catFile#,#Project#.#MSG_DEBUG#)#;#try#{#parseCatalog#.#invoke#(#resolverImpl#,#new#Object#[#]#{#catFile#.#getPath#(#)#}#)#;#}#catch#(#Exception#ex#)#{#throw#new#BuildException#(#ex#)#;#}#}#}#}#externalCatalogsProcessed#=#true#;#}##