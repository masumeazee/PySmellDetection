void#setLongFileMode#(#int#longFileMode#)#{#this#.#longFileMode#=#longFileMode#;#}##void#setDebug#(#boolean#debugF#)#{#this#.#debug#=#debugF#;#}##void#setBufferDebug#(#boolean#debug#)#{#buffer#.#setDebug#(#debug#)#;#}##void#finish#(#)#throws#IOException#{#// See Bugzilla 28776 for a discussion on this#// http://issues.apache.org/bugzilla/show_bug.cgi?id=28776#writeEOFRecord#(#)#;#writeEOFRecord#(#)#;#}##void#close#(#)#throws#IOException#{#if#(#!#closed#)#{#finish#(#)#;#buffer#.#close#(#)#;#out#.#close#(#)#;#closed#=#true#;#}#}##int#getRecordSize#(#)#{#return#buffer#.#getRecordSize#(#)#;#}##void#putNextEntry#(#TarEntry#entry#)#throws#IOException#{#if#(#entry#.#getName#(#)#.#length#(#)#>=#TarConstants#.#NAMELEN#)#{#if#(#longFileMode#==#LONGFILE_GNU#)#{#// create a TarEntry for the LongLink, the contents#// of which are the entry's name#TarEntry#longLinkEntry#=#new#TarEntry#(#TarConstants#.#GNU_LONGLINK#,#TarConstants#.#LF_GNUTYPE_LONGNAME#)#;#longLinkEntry#.#setSize#(#entry#.#getName#(#)#.#length#(#)#+#1#)#;#putNextEntry#(#longLinkEntry#)#;#write#(#entry#.#getName#(#)#.#getBytes#(#)#)#;#write#(#0#)#;#closeEntry#(#)#;#}#else#if#(#longFileMode#!=#LONGFILE_TRUNCATE#)#{#throw#new#RuntimeException#(#"file name '"#+#entry#.#getName#(#)#+#"' is too long ( > "#+#TarConstants#.#NAMELEN#+#" bytes)"#)#;#}#}#entry#.#writeEntryHeader#(#recordBuf#)#;#buffer#.#writeRecord#(#recordBuf#)#;#currBytes#=#0#;#if#(#entry#.#isDirectory#(#)#)#{#currSize#=#0#;#}#else#{#currSize#=#entry#.#getSize#(#)#;#}#currName#=#entry#.#getName#(#)#;#}##void#closeEntry#(#)#throws#IOException#{#if#(#assemLen#>#0#)#{#for#(#int#i#=#assemLen#;#i#<#assemBuf#.#length#;#++#i#)#{#assemBuf#[#i#]#=#0#;#}#buffer#.#writeRecord#(#assemBuf#)#;#currBytes#+=#assemLen#;#assemLen#=#0#;#}#if#(#currBytes#<#currSize#)#{#throw#new#IOException#(#"entry '"#+#currName#+#"' closed at '"#+#currBytes#+#"' before the '"#+#currSize#+#"' bytes specified in the header were written"#)#;#}#}##void#write#(#int#b#)#throws#IOException#{#oneBuf#[#0#]#=#(#byte#)#b#;#write#(#oneBuf#,#0#,#1#)#;#}##void#write#(#byte#[#]#wBuf#)#throws#IOException#{#write#(#wBuf#,#0#,#wBuf#.#length#)#;#}##void#write#(#byte#[#]#wBuf#,#int#wOffset#,#int#numToWrite#)#throws#IOException#{#if#(#(#currBytes#+#numToWrite#)#>#currSize#)#{#throw#new#IOException#(#"request to write '"#+#numToWrite#+#"' bytes exceeds size in header of '"#+#currSize#+#"' bytes for entry '"#+#currName#+#"'"#)#;#//#// We have to deal with assembly!!!#// The programmer can be writing little 32 byte chunks for all#// we know, and we must assemble complete records for writing.#// REVIEW Maybe this should be in TarBuffer? Could that help to#// eliminate some of the buffer copying.#//#}#if#(#assemLen#>#0#)#{#if#(#(#assemLen#+#numToWrite#)#>=#recordBuf#.#length#)#{#int#aLen#=#recordBuf#.#length#-#assemLen#;#System#.#arraycopy#(#assemBuf#,#0#,#recordBuf#,#0#,#assemLen#)#;#System#.#arraycopy#(#wBuf#,#wOffset#,#recordBuf#,#assemLen#,#aLen#)#;#buffer#.#writeRecord#(#recordBuf#)#;#currBytes#+=#recordBuf#.#length#;#wOffset#+=#aLen#;#numToWrite#-=#aLen#;#assemLen#=#0#;#}#else#{#System#.#arraycopy#(#wBuf#,#wOffset#,#assemBuf#,#assemLen#,#numToWrite#)#;#wOffset#+=#numToWrite#;#assemLen#+=#numToWrite#;#numToWrite#=#0#;#}#}#//#// When we get here we have EITHER:#// o An empty "assemble" buffer.#// o No bytes to write (numToWrite == 0)#//#while#(#numToWrite#>#0#)#{#if#(#numToWrite#<#recordBuf#.#length#)#{#System#.#arraycopy#(#wBuf#,#wOffset#,#assemBuf#,#assemLen#,#numToWrite#)#;#assemLen#+=#numToWrite#;#break#;#}#buffer#.#writeRecord#(#wBuf#,#wOffset#)#;#int#num#=#recordBuf#.#length#;#currBytes#+=#num#;#numToWrite#-=#num#;#wOffset#+=#num#;#}#}##void#writeEOFRecord#(#)#throws#IOException#{#for#(#int#i#=#0#;#i#<#recordBuf#.#length#;#++#i#)#{#recordBuf#[#i#]#=#0#;#}#buffer#.#writeRecord#(#recordBuf#)#;#}##