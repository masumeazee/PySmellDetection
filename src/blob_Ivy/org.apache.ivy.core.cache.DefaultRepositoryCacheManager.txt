IvySettings#getSettings#(#)#{#return#settings#;#}##void#setSettings#(#IvySettings#settings#)#{#this#.#settings#=#settings#;#}##File#getIvyFileInCache#(#ModuleRevisionId#mrid#)#{#String#file#=#IvyPatternHelper#.#substitute#(#getIvyPattern#(#)#,#DefaultArtifact#.#newIvyArtifact#(#mrid#,#null#)#)#;#return#new#File#(#getRepositoryCacheRoot#(#)#,#file#)#;#}##String#getIvyPattern#(#)#{#if#(#ivyPattern#==#null#)#{#if#(#settings#!=#null#)#{#ivyPattern#=#settings#.#getDefaultCacheIvyPattern#(#)#;#}#if#(#ivyPattern#==#null#)#{#ivyPattern#=#DEFAULT_IVY_PATTERN#;#}#}#return#ivyPattern#;#}##String#getArtifactPattern#(#)#{#if#(#artifactPattern#==#null#)#{#if#(#settings#!=#null#)#{#artifactPattern#=#settings#.#getDefaultCacheArtifactPattern#(#)#;#}#if#(#artifactPattern#==#null#)#{#artifactPattern#=#DEFAULT_ARTIFACT_PATTERN#;#}#}#return#artifactPattern#;#}##void#setArtifactPattern#(#String#artifactPattern#)#{#CacheUtil#.#checkCachePattern#(#artifactPattern#)#;#this#.#artifactPattern#=#artifactPattern#;#}##File#getBasedir#(#)#{#if#(#basedir#==#null#)#{#basedir#=#settings#.#getDefaultRepositoryCacheBasedir#(#)#;#}#return#basedir#;#}##void#setBasedir#(#File#cache#)#{#this#.#basedir#=#cache#;#}##long#getDefaultTTL#(#)#{#if#(#defaultTTL#==#null#)#{#defaultTTL#=#new#Long#(#parseDuration#(#settings#.#getVariable#(#"ivy.cache.ttl.default"#)#)#)#;#}#return#defaultTTL#.#longValue#(#)#;#}##void#setDefaultTTL#(#long#defaultTTL#)#{#this#.#defaultTTL#=#new#Long#(#defaultTTL#)#;#}##void#setDefaultTTL#(#String#defaultTTL#)#{#this#.#defaultTTL#=#new#Long#(#parseDuration#(#defaultTTL#)#)#;#}##String#getDataFilePattern#(#)#{#return#dataFilePattern#;#}##void#setDataFilePattern#(#String#dataFilePattern#)#{#CacheUtil#.#checkCachePattern#(#dataFilePattern#)#;#this#.#dataFilePattern#=#dataFilePattern#;#}##void#setIvyPattern#(#String#ivyPattern#)#{#CacheUtil#.#checkCachePattern#(#ivyPattern#)#;#this#.#ivyPattern#=#ivyPattern#;#}##String#getName#(#)#{#return#name#;#}##void#setName#(#String#name#)#{#this#.#name#=#name#;#}##String#getChangingMatcherName#(#)#{#return#changingMatcherName#;#}##void#setChangingMatcher#(#String#changingMatcherName#)#{#this#.#changingMatcherName#=#changingMatcherName#;#}##String#getChangingPattern#(#)#{#return#changingPattern#;#}##void#setChangingPattern#(#String#changingPattern#)#{#this#.#changingPattern#=#changingPattern#;#}##void#addTTL#(#Map#attributes#,#PatternMatcher#matcher#,#long#duration#)#{#ttlRules#.#defineRule#(#new#MapMatcher#(#attributes#,#matcher#)#,#new#Long#(#duration#)#)#;#}##void#addConfiguredTtl#(#Map#/*<String,String>*/#attributes#)#{#String#duration#=#(#String#)#attributes#.#remove#(#"duration"#)#;#if#(#duration#==#null#)#{#throw#new#IllegalArgumentException#(#"'duration' attribute is mandatory for ttl"#)#;#}#String#matcher#=#(#String#)#attributes#.#remove#(#"matcher"#)#;#addTTL#(#attributes#,#matcher#==#null#?#ExactPatternMatcher#.#INSTANCE#:#settings#.#getMatcher#(#matcher#)#,#parseDuration#(#duration#)#)#;#}##void#setMemorySize#(#int#size#)#{#memoryModuleDescrCache#=#new#ModuleDescriptorMemoryCache#(#size#)#;#}##ModuleDescriptorMemoryCache#getMemoryCache#(#)#{#if#(#memoryModuleDescrCache#==#null#)#{#memoryModuleDescrCache#=#new#ModuleDescriptorMemoryCache#(#DEFAULT_MEMORY_CACHE_SIZE#)#;#}#return#memoryModuleDescrCache#;#}##long#parseDuration#(#String#duration#)#{#if#(#duration#==#null#)#{#return#0#;#}#if#(#"eternal"#.#equals#(#duration#)#)#{#return#Long#.#MAX_VALUE#;#}#java#.#util#.#regex#.#Matcher#m#=#DURATION_PATTERN#.#matcher#(#duration#)#;#if#(#m#.#matches#(#)#)#{#//CheckStyle:MagicNumber| OFF#int#days#=#getGroupIntValue#(#m#,#1#)#;#int#hours#=#getGroupIntValue#(#m#,#2#)#;#int#minutes#=#getGroupIntValue#(#m#,#3#)#;#int#seconds#=#getGroupIntValue#(#m#,#4#)#;#int#millis#=#getGroupIntValue#(#m#,#5#)#;#//CheckStyle:MagicNumber| ON#return#days#*#MILLIS_IN_DAY#+#hours#*#MILLIS_IN_HOUR#+#minutes#*#MILLIS_IN_MINUTES#+#seconds#*#MILLIS_IN_SECONDS#+#millis#;#}#else#{#throw#new#IllegalArgumentException#(#"invalid duration '"#+#duration#+#"': it must match "#+#DURATION_PATTERN#.#pattern#(#)#+#" or 'eternal'"#)#;#}#}##int#getGroupIntValue#(#java#.#util#.#regex#.#Matcher#m#,#int#groupNumber#)#{#String#g#=#m#.#group#(#groupNumber#)#;#return#g#==#null#||#g#.#length#(#)#==#0#?#0#:#Integer#.#parseInt#(#g#)#;#}##boolean#isCheckmodified#(#)#{#if#(#checkmodified#==#null#)#{#if#(#getSettings#(#)#!=#null#)#{#String#check#=#getSettings#(#)#.#getVariable#(#"ivy.resolver.default.check.modified"#)#;#return#check#!=#null#?#Boolean#.#valueOf#(#check#)#.#booleanValue#(#)#:#false#;#}#else#{#return#false#;#}#}#else#{#return#checkmodified#.#booleanValue#(#)#;#}#}##void#setCheckmodified#(#boolean#check#)#{#checkmodified#=#Boolean#.#valueOf#(#check#)#;#}##boolean#isUseOrigin#(#)#{#if#(#useOrigin#==#null#)#{#if#(#getSettings#(#)#!=#null#)#{#return#getSettings#(#)#.#isDefaultUseOrigin#(#)#;#}#else#{#return#false#;#}#}#else#{#return#useOrigin#.#booleanValue#(#)#;#}#}##void#setUseOrigin#(#boolean#b#)#{#useOrigin#=#Boolean#.#valueOf#(#b#)#;#}##File#getArchiveFileInCache#(#Artifact#artifact#)#{#ArtifactOrigin#origin#=#getSavedArtifactOrigin#(#artifact#)#;#return#getArchiveFileInCache#(#artifact#,#origin#)#;#}##File#getArchiveFileInCache#(#Artifact#artifact#,#ArtifactOrigin#origin#)#{#File#archive#=#new#File#(#getRepositoryCacheRoot#(#)#,#getArchivePathInCache#(#artifact#,#origin#)#)#;#if#(#!#archive#.#exists#(#)#&&#!#ArtifactOrigin#.#isUnknown#(#origin#)#&&#origin#.#isLocal#(#)#)#{#File#original#=#Checks#.#checkAbsolute#(#origin#.#getLocation#(#)#,#artifact#+#" origin location"#)#;#if#(#original#.#exists#(#)#)#{#return#original#;#}#}#return#archive#;#}##File#getArchiveFileInCache#(#Artifact#artifact#,#ArtifactOrigin#origin#,#boolean#useOrigin#)#{#if#(#useOrigin#&&#!#ArtifactOrigin#.#isUnknown#(#origin#)#&&#origin#.#isLocal#(#)#)#{#return#Checks#.#checkAbsolute#(#origin#.#getLocation#(#)#,#artifact#+#" origin location"#)#;#}#else#{#return#new#File#(#getRepositoryCacheRoot#(#)#,#getArchivePathInCache#(#artifact#,#origin#)#)#;#}#}##String#getArchivePathInCache#(#Artifact#artifact#)#{#return#IvyPatternHelper#.#substitute#(#getArtifactPattern#(#)#,#artifact#)#;#}##String#getArchivePathInCache#(#Artifact#artifact#,#ArtifactOrigin#origin#)#{#if#(#isOriginalMetadataArtifact#(#artifact#)#)#{#return#IvyPatternHelper#.#substitute#(#getIvyPattern#(#)#+#".original"#,#artifact#,#origin#)#;#}#else#{#return#IvyPatternHelper#.#substitute#(#getArtifactPattern#(#)#,#artifact#,#origin#)#;#}#}##void#saveResolver#(#ModuleDescriptor#md#,#String#name#)#{#// should always be called with a lock on module metadata artifact#PropertiesFile#cdf#=#getCachedDataFile#(#md#)#;#cdf#.#setProperty#(#"resolver"#,#name#)#;#cdf#.#save#(#)#;#}##void#saveResolvers#(#ModuleDescriptor#md#,#String#metadataResolverName#,#String#artifactResolverName#)#{#ModuleRevisionId#mrid#=#md#.#getResolvedModuleRevisionId#(#)#;#if#(#!#lockMetadataArtifact#(#mrid#)#)#{#Message#.#error#(#"impossible to acquire lock for "#+#mrid#)#;#return#;#}#try#{#PropertiesFile#cdf#=#getCachedDataFile#(#md#)#;#cdf#.#setProperty#(#"resolver"#,#metadataResolverName#)#;#cdf#.#setProperty#(#"artifact.resolver"#,#artifactResolverName#)#;#cdf#.#save#(#)#;#}#finally#{#unlockMetadataArtifact#(#mrid#)#;#}#}##String#getSavedResolverName#(#ModuleDescriptor#md#)#{#// should always be called with a lock on module metadata artifact#PropertiesFile#cdf#=#getCachedDataFile#(#md#)#;#return#cdf#.#getProperty#(#"resolver"#)#;#}##String#getSavedArtResolverName#(#ModuleDescriptor#md#)#{#// should always be called with a lock on module metadata artifact#PropertiesFile#cdf#=#getCachedDataFile#(#md#)#;#return#cdf#.#getProperty#(#"artifact.resolver"#)#;#}##void#saveArtifactOrigin#(#Artifact#artifact#,#ArtifactOrigin#origin#)#{#// should always be called with a lock on module metadata artifact#PropertiesFile#cdf#=#getCachedDataFile#(#artifact#.#getModuleRevisionId#(#)#)#;#cdf#.#setProperty#(#getIsLocalKey#(#artifact#)#,#String#.#valueOf#(#origin#.#isLocal#(#)#)#)#;#cdf#.#setProperty#(#getLocationKey#(#artifact#)#,#origin#.#getLocation#(#)#)#;#cdf#.#save#(#)#;#}##void#removeSavedArtifactOrigin#(#Artifact#artifact#)#{#// should always be called with a lock on module metadata artifact#PropertiesFile#cdf#=#getCachedDataFile#(#artifact#.#getModuleRevisionId#(#)#)#;#cdf#.#remove#(#getLocationKey#(#artifact#)#)#;#cdf#.#remove#(#getIsLocalKey#(#artifact#)#)#;#cdf#.#save#(#)#;#}##ArtifactOrigin#getSavedArtifactOrigin#(#Artifact#artifact#)#{#ModuleRevisionId#mrid#=#artifact#.#getModuleRevisionId#(#)#;#if#(#!#lockMetadataArtifact#(#mrid#)#)#{#Message#.#error#(#"impossible to acquire lock for "#+#mrid#)#;#return#ArtifactOrigin#.#unkwnown#(#artifact#)#;#}#try#{#PropertiesFile#cdf#=#getCachedDataFile#(#artifact#.#getModuleRevisionId#(#)#)#;#String#location#=#cdf#.#getProperty#(#getLocationKey#(#artifact#)#)#;#String#local#=#cdf#.#getProperty#(#getIsLocalKey#(#artifact#)#)#;#boolean#isLocal#=#Boolean#.#valueOf#(#local#)#.#booleanValue#(#)#;#if#(#location#==#null#)#{#// origin has not been specified, return null#return#ArtifactOrigin#.#unkwnown#(#artifact#)#;#}#return#new#ArtifactOrigin#(#artifact#,#isLocal#,#location#)#;#}#finally#{#unlockMetadataArtifact#(#mrid#)#;#}#}##String#getPrefixKey#(#Artifact#artifact#)#{#// use the hashcode as a uuid for the artifact (fingers crossed)#int#hashCode#=#artifact#.#getId#(#)#.#hashCode#(#)#;#// use just some visual cue#return#"artifact:"#+#artifact#.#getName#(#)#+#"#"#+#artifact#.#getType#(#)#+#"#"#+#artifact#.#getExt#(#)#+#"#"#+#hashCode#;#}##String#getLocationKey#(#Artifact#artifact#)#{#String#prefix#=#getPrefixKey#(#artifact#)#;#return#prefix#+#".location"#;#}##String#getIsLocalKey#(#Artifact#artifact#)#{#String#prefix#=#getPrefixKey#(#artifact#)#;#return#prefix#+#".is-local"#;#}##PropertiesFile#getCachedDataFile#(#ModuleDescriptor#md#)#{#return#getCachedDataFile#(#md#.#getResolvedModuleRevisionId#(#)#)#;#}##PropertiesFile#getCachedDataFile#(#ModuleRevisionId#mRevId#)#{#return#new#PropertiesFile#(#new#File#(#getRepositoryCacheRoot#(#)#,#IvyPatternHelper#.#substitute#(#getDataFilePattern#(#)#,#mRevId#)#)#,#"ivy cached data file for "#+#mRevId#)#;#}##ResolvedModuleRevision#findModuleInCache#(#DependencyDescriptor#dd#,#ModuleRevisionId#requestedRevisionId#,#CacheMetadataOptions#options#,#String#expectedResolver#)#{#ModuleRevisionId#mrid#=#requestedRevisionId#;#if#(#isCheckmodified#(#dd#,#requestedRevisionId#,#options#)#)#{#Message#.#verbose#(#"don't use cache for "#+#mrid#+#": checkModified=true"#)#;#return#null#;#}#if#(#isChanging#(#dd#,#requestedRevisionId#,#options#)#)#{#Message#.#verbose#(#"don't use cache for "#+#mrid#+#": changing=true"#)#;#return#null#;#}#return#doFindModuleInCache#(#mrid#,#options#,#expectedResolver#)#;#}##ResolvedModuleRevision#doFindModuleInCache#(#ModuleRevisionId#mrid#,#CacheMetadataOptions#options#,#String#expectedResolver#)#{#if#(#!#lockMetadataArtifact#(#mrid#)#)#{#Message#.#error#(#"impossible to acquire lock for "#+#mrid#)#;#return#null#;#}#try#{#if#(#settings#.#getVersionMatcher#(#)#.#isDynamic#(#mrid#)#)#{#String#resolvedRevision#=#getResolvedRevision#(#mrid#,#options#)#;#if#(#resolvedRevision#!=#null#)#{#Message#.#verbose#(#"found resolved revision in cache: "#+#mrid#+#" => "#+#resolvedRevision#)#;#mrid#=#ModuleRevisionId#.#newInstance#(#mrid#,#resolvedRevision#)#;#}#else#{#return#null#;#}#}#File#ivyFile#=#getIvyFileInCache#(#mrid#)#;#if#(#ivyFile#.#exists#(#)#)#{#// found in cache !#try#{#XmlModuleDescriptorParser#parser#=#XmlModuleDescriptorParser#.#getInstance#(#)#;#ModuleDescriptor#depMD#=#getMdFromCache#(#parser#,#options#,#ivyFile#)#;#String#resolverName#=#getSavedResolverName#(#depMD#)#;#String#artResolverName#=#getSavedArtResolverName#(#depMD#)#;#DependencyResolver#resolver#=#settings#.#getResolver#(#resolverName#)#;#if#(#resolver#==#null#)#{#Message#.#debug#(#"\tresolver not found: "#+#resolverName#+#" => trying to use the one configured for "#+#mrid#)#;#resolver#=#settings#.#getResolver#(#depMD#.#getResolvedModuleRevisionId#(#)#)#;#if#(#resolver#!=#null#)#{#Message#.#debug#(#"\tconfigured resolver found for "#+#depMD#.#getResolvedModuleRevisionId#(#)#+#": "#+#resolver#.#getName#(#)#+#": saving this data"#)#;#saveResolver#(#depMD#,#resolver#.#getName#(#)#)#;#}#}#DependencyResolver#artResolver#=#settings#.#getResolver#(#artResolverName#)#;#if#(#artResolver#==#null#)#{#artResolver#=#resolver#;#}#if#(#resolver#!=#null#)#{#Message#.#debug#(#"\tfound ivy file in cache for "#+#mrid#+#" (resolved by "#+#resolver#.#getName#(#)#+#"): "#+#ivyFile#)#;#if#(#expectedResolver#==#null#||#expectedResolver#.#equals#(#resolver#.#getName#(#)#)#)#{#MetadataArtifactDownloadReport#madr#=#new#MetadataArtifactDownloadReport#(#depMD#.#getMetadataArtifact#(#)#)#;#madr#.#setDownloadStatus#(#DownloadStatus#.#NO#)#;#madr#.#setSearched#(#false#)#;#madr#.#setLocalFile#(#ivyFile#)#;#madr#.#setSize#(#ivyFile#.#length#(#)#)#;#madr#.#setArtifactOrigin#(#getSavedArtifactOrigin#(#depMD#.#getMetadataArtifact#(#)#)#)#;#return#new#ResolvedModuleRevision#(#resolver#,#artResolver#,#depMD#,#madr#)#;#}#else#{#Message#.#debug#(#"found module in cache but with a different resolver: "#+#"discarding: "#+#mrid#+#"; expected resolver="#+#expectedResolver#+#"; resolver="#+#resolver#.#getName#(#)#)#;#}#}#else#{#Message#.#debug#(#"\tresolver not found: "#+#resolverName#+#" => cannot use cached ivy file for "#+#mrid#)#;#}#}#catch#(#Exception#e#)#{#// will try with resolver#Message#.#debug#(#"\tproblem while parsing cached ivy file for: "#+#mrid#+#": "#+#e#.#getMessage#(#)#)#;#}#}#else#{#Message#.#debug#(#"\tno ivy file in cache for "#+#mrid#+#": tried "#+#ivyFile#)#;#}#}#finally#{#unlockMetadataArtifact#(#mrid#)#;#}#return#null#;#}##ModuleDescriptor#provideModule#(#ParserSettings#ivySettings#,#File#descriptorURL#,#boolean#validate#)#throws#ParseException#,#IOException#{#return#mdParser#.#parseDescriptor#(#ivySettings#,#descriptorURL#.#toURI#(#)#.#toURL#(#)#,#validate#)#;#}##ModuleDescriptor#getMdFromCache#(#XmlModuleDescriptorParser#mdParser#,#CacheMetadataOptions#options#,#File#ivyFile#)#throws#ParseException#,#IOException#{#ModuleDescriptorMemoryCache#cache#=#getMemoryCache#(#)#;#ModuleDescriptorProvider#mdProvider#=#new#MyModuleDescriptorProvider#(#mdParser#)#;#return#cache#.#get#(#ivyFile#,#settings#,#options#.#isValidate#(#)#,#mdProvider#)#;#}##ModuleDescriptor#getStaledMd#(#ModuleDescriptorParser#mdParser#,#CacheMetadataOptions#options#,#File#ivyFile#)#throws#ParseException#,#IOException#{#ModuleDescriptorMemoryCache#cache#=#getMemoryCache#(#)#;#ModuleDescriptorProvider#mdProvider#=#new#MyModuleDescriptorProvider#(#mdParser#)#;#return#cache#.#getStale#(#ivyFile#,#settings#,#options#.#isValidate#(#)#,#mdProvider#)#;#}##String#getResolvedRevision#(#ModuleRevisionId#mrid#,#CacheMetadataOptions#options#)#{#if#(#!#lockMetadataArtifact#(#mrid#)#)#{#Message#.#error#(#"impossible to acquire lock for "#+#mrid#)#;#return#null#;#}#try#{#String#resolvedRevision#=#null#;#if#(#options#.#isForce#(#)#)#{#Message#.#verbose#(#"refresh mode: no check for cached resolved revision for "#+#mrid#)#;#return#null#;#}#PropertiesFile#cachedResolvedRevision#=#getCachedDataFile#(#mrid#)#;#resolvedRevision#=#cachedResolvedRevision#.#getProperty#(#"resolved.revision"#)#;#if#(#resolvedRevision#==#null#)#{#Message#.#verbose#(#getName#(#)#+#": no cached resolved revision for "#+#mrid#)#;#return#null#;#}#String#resolvedTime#=#cachedResolvedRevision#.#getProperty#(#"resolved.time"#)#;#if#(#resolvedTime#==#null#)#{#Message#.#verbose#(#getName#(#)#+#": inconsistent or old cache: no cached resolved time for "#+#mrid#)#;#saveResolvedRevision#(#mrid#,#resolvedRevision#)#;#return#resolvedRevision#;#}#long#expiration#=#Long#.#parseLong#(#resolvedTime#)#+#getTTL#(#mrid#)#;#if#(#expiration#>#0#// negative expiration means that Long.MAX_VALUE has been exceeded#&&#System#.#currentTimeMillis#(#)#>#expiration#)#{#Message#.#verbose#(#getName#(#)#+#": cached resolved revision expired for "#+#mrid#)#;#return#null#;#}#return#resolvedRevision#;#}#finally#{#unlockMetadataArtifact#(#mrid#)#;#}#}##void#saveResolvedRevision#(#ModuleRevisionId#mrid#,#String#revision#)#{#if#(#!#lockMetadataArtifact#(#mrid#)#)#{#Message#.#error#(#"impossible to acquire lock for "#+#mrid#)#;#return#;#}#try#{#PropertiesFile#cachedResolvedRevision#=#getCachedDataFile#(#mrid#)#;#cachedResolvedRevision#.#setProperty#(#"resolved.time"#,#String#.#valueOf#(#System#.#currentTimeMillis#(#)#)#)#;#cachedResolvedRevision#.#setProperty#(#"resolved.revision"#,#revision#)#;#cachedResolvedRevision#.#save#(#)#;#}#finally#{#unlockMetadataArtifact#(#mrid#)#;#}#}##long#getTTL#(#ModuleRevisionId#mrid#)#{#Long#ttl#=#(#Long#)#ttlRules#.#getRule#(#mrid#)#;#return#ttl#==#null#?#getDefaultTTL#(#)#:#ttl#.#longValue#(#)#;#}##String#toString#(#)#{#return#name#;#}##File#getRepositoryCacheRoot#(#)#{#return#getBasedir#(#)#;#}##LockStrategy#getLockStrategy#(#)#{#if#(#lockStrategy#==#null#)#{#if#(#lockStrategyName#!=#null#)#{#lockStrategy#=#settings#.#getLockStrategy#(#lockStrategyName#)#;#}#else#{#lockStrategy#=#settings#.#getDefaultLockStrategy#(#)#;#}#}#return#lockStrategy#;#}##void#setLockStrategy#(#LockStrategy#lockStrategy#)#{#this#.#lockStrategy#=#lockStrategy#;#}##void#setLockStrategy#(#String#lockStrategyName#)#{#this#.#lockStrategyName#=#lockStrategyName#;#}##ArtifactDownloadReport#download#(#Artifact#artifact#,#ArtifactResourceResolver#resourceResolver#,#ResourceDownloader#resourceDownloader#,#CacheDownloadOptions#options#)#{#final#ArtifactDownloadReport#adr#=#new#ArtifactDownloadReport#(#artifact#)#;#boolean#useOrigin#=#isUseOrigin#(#)#;#// TODO: see if we could lock on the artifact to download only, instead of the module#// metadata artifact. We'd need to store artifact origin and is local in artifact specific#// file to do so, or lock the metadata artifact only to update artifact origin, which would#// mean acquiring nested locks, which can be a dangerous thing#ModuleRevisionId#mrid#=#artifact#.#getModuleRevisionId#(#)#;#if#(#!#lockMetadataArtifact#(#mrid#)#)#{#adr#.#setDownloadStatus#(#DownloadStatus#.#FAILED#)#;#adr#.#setDownloadDetails#(#"impossible to get lock for "#+#mrid#)#;#return#adr#;#}#try#{#DownloadListener#listener#=#options#.#getListener#(#)#;#if#(#listener#!=#null#)#{#listener#.#needArtifact#(#this#,#artifact#)#;#}#ArtifactOrigin#origin#=#getSavedArtifactOrigin#(#artifact#)#;#// if we can use origin file, we just ask ivy for the file in cache, and it will#// return the original one if possible. If we are not in useOrigin mode, we use the#// getArchivePath method which always return a path in the actual cache#File#archiveFile#=#getArchiveFileInCache#(#artifact#,#origin#,#useOrigin#)#;#if#(#archiveFile#.#exists#(#)#&&#!#options#.#isForce#(#)#)#{#adr#.#setDownloadStatus#(#DownloadStatus#.#NO#)#;#adr#.#setSize#(#archiveFile#.#length#(#)#)#;#adr#.#setArtifactOrigin#(#origin#)#;#adr#.#setLocalFile#(#archiveFile#)#;#}#else#{#long#start#=#System#.#currentTimeMillis#(#)#;#try#{#ResolvedResource#artifactRef#=#resourceResolver#.#resolve#(#artifact#)#;#if#(#artifactRef#!=#null#)#{#origin#=#new#ArtifactOrigin#(#artifact#,#artifactRef#.#getResource#(#)#.#isLocal#(#)#,#artifactRef#.#getResource#(#)#.#getName#(#)#)#;#if#(#useOrigin#&&#artifactRef#.#getResource#(#)#.#isLocal#(#)#)#{#saveArtifactOrigin#(#artifact#,#origin#)#;#archiveFile#=#getArchiveFileInCache#(#artifact#,#origin#)#;#adr#.#setDownloadStatus#(#DownloadStatus#.#NO#)#;#adr#.#setSize#(#archiveFile#.#length#(#)#)#;#adr#.#setArtifactOrigin#(#origin#)#;#adr#.#setLocalFile#(#archiveFile#)#;#}#else#{#// refresh archive file now that we better now its origin#archiveFile#=#getArchiveFileInCache#(#artifact#,#origin#,#useOrigin#)#;#if#(#ResourceHelper#.#equals#(#artifactRef#.#getResource#(#)#,#archiveFile#)#)#{#throw#new#IllegalStateException#(#"invalid settings for '"#+#resourceResolver#+#"': pointing repository to ivy cache is forbidden !"#)#;#}#if#(#listener#!=#null#)#{#listener#.#startArtifactDownload#(#this#,#artifactRef#,#artifact#,#origin#)#;#}#resourceDownloader#.#download#(#artifact#,#artifactRef#.#getResource#(#)#,#archiveFile#)#;#adr#.#setSize#(#archiveFile#.#length#(#)#)#;#saveArtifactOrigin#(#artifact#,#origin#)#;#adr#.#setDownloadTimeMillis#(#System#.#currentTimeMillis#(#)#-#start#)#;#adr#.#setDownloadStatus#(#DownloadStatus#.#SUCCESSFUL#)#;#adr#.#setArtifactOrigin#(#origin#)#;#adr#.#setLocalFile#(#archiveFile#)#;#}#}#else#{#adr#.#setDownloadStatus#(#DownloadStatus#.#FAILED#)#;#adr#.#setDownloadDetails#(#ArtifactDownloadReport#.#MISSING_ARTIFACT#)#;#adr#.#setDownloadTimeMillis#(#System#.#currentTimeMillis#(#)#-#start#)#;#}#}#catch#(#Exception#ex#)#{#adr#.#setDownloadStatus#(#DownloadStatus#.#FAILED#)#;#adr#.#setDownloadDetails#(#ex#.#getMessage#(#)#)#;#adr#.#setDownloadTimeMillis#(#System#.#currentTimeMillis#(#)#-#start#)#;#}#}#if#(#listener#!=#null#)#{#listener#.#endArtifactDownload#(#this#,#artifact#,#adr#,#archiveFile#)#;#}#return#adr#;#}#finally#{#unlockMetadataArtifact#(#mrid#)#;#}#}##void#originalToCachedModuleDescriptor#(#DependencyResolver#resolver#,#ResolvedResource#orginalMetadataRef#,#Artifact#requestedMetadataArtifact#,#ResolvedModuleRevision#rmr#,#ModuleDescriptorWriter#writer#)#{#ModuleDescriptor#md#=#rmr#.#getDescriptor#(#)#;#Artifact#originalMetadataArtifact#=#getOriginalMetadataArtifact#(#requestedMetadataArtifact#)#;#File#mdFileInCache#=#getIvyFileInCache#(#md#.#getResolvedModuleRevisionId#(#)#)#;#ModuleRevisionId#mrid#=#requestedMetadataArtifact#.#getModuleRevisionId#(#)#;#if#(#!#lockMetadataArtifact#(#mrid#)#)#{#Message#.#warn#(#"impossible to acquire lock for: "#+#mrid#)#;#return#;#}#try#{#File#originalFileInCache#=#getArchiveFileInCache#(#originalMetadataArtifact#)#;#writer#.#write#(#orginalMetadataRef#,#md#,#originalFileInCache#,#mdFileInCache#)#;#saveResolvers#(#md#,#resolver#.#getName#(#)#,#resolver#.#getName#(#)#)#;#if#(#!#md#.#isDefault#(#)#)#{#rmr#.#getReport#(#)#.#setOriginalLocalFile#(#originalFileInCache#)#;#}#rmr#.#getReport#(#)#.#setLocalFile#(#mdFileInCache#)#;#}#catch#(#RuntimeException#e#)#{#throw#e#;#}#catch#(#Exception#e#)#{#Message#.#warn#(#"impossible to put metadata file in cache: "#+#(#orginalMetadataRef#==#null#?#String#.#valueOf#(#md#.#getResolvedModuleRevisionId#(#)#)#:#String#.#valueOf#(#orginalMetadataRef#)#)#+#". "#+#e#.#getClass#(#)#.#getName#(#)#+#": "#+#e#.#getMessage#(#)#)#;#}#finally#{#unlockMetadataArtifact#(#mrid#)#;#}#}##ResolvedModuleRevision#cacheModuleDescriptor#(#DependencyResolver#resolver#,#final#ResolvedResource#mdRef#,#DependencyDescriptor#dd#,#Artifact#moduleArtifact#,#ResourceDownloader#downloader#,#CacheMetadataOptions#options#)#throws#ParseException#{#ModuleDescriptorParser#parser#=#ModuleDescriptorParserRegistry#.#getInstance#(#)#.#getParser#(#mdRef#.#getResource#(#)#)#;#Date#cachedPublicationDate#=#null#;#ArtifactDownloadReport#report#;#ModuleRevisionId#mrid#=#moduleArtifact#.#getModuleRevisionId#(#)#;#Artifact#originalMetadataArtifact#=#getOriginalMetadataArtifact#(#moduleArtifact#)#;#if#(#!#lockMetadataArtifact#(#mrid#)#)#{#Message#.#error#(#"impossible to acquire lock for "#+#mrid#)#;#return#null#;#}#BackupResourceDownloader#backupDownloader#=#new#BackupResourceDownloader#(#downloader#)#;#try#{#// now let's see if we can find it in cache and if it is up to date#ResolvedModuleRevision#rmr#=#doFindModuleInCache#(#mrid#,#options#,#null#)#;#if#(#rmr#!=#null#)#{#if#(#rmr#.#getDescriptor#(#)#.#isDefault#(#)#&&#rmr#.#getResolver#(#)#!=#resolver#)#{#Message#.#verbose#(#"\t"#+#getName#(#)#+#": found revision in cache: "#+#mrid#+#" (resolved by "#+#rmr#.#getResolver#(#)#.#getName#(#)#+#"): but it's a default one, maybe we can find a better one"#)#;#}#else#{#if#(#!#isCheckmodified#(#dd#,#mrid#,#options#)#&&#!#isChanging#(#dd#,#mrid#,#options#)#)#{#Message#.#verbose#(#"\t"#+#getName#(#)#+#": revision in cache: "#+#mrid#)#;#rmr#.#getReport#(#)#.#setSearched#(#true#)#;#return#rmr#;#}#long#repLastModified#=#mdRef#.#getLastModified#(#)#;#long#cacheLastModified#=#rmr#.#getDescriptor#(#)#.#getLastModified#(#)#;#if#(#!#rmr#.#getDescriptor#(#)#.#isDefault#(#)#&&#repLastModified#<=#cacheLastModified#)#{#Message#.#verbose#(#"\t"#+#getName#(#)#+#": revision in cache (not updated): "#+#mrid#)#;#rmr#.#getReport#(#)#.#setSearched#(#true#)#;#return#rmr#;#}#else#{#Message#.#verbose#(#"\t"#+#getName#(#)#+#": revision in cache is not up to date: "#+#mrid#)#;#if#(#isChanging#(#dd#,#mrid#,#options#)#)#{#// ivy file has been updated, we should see if it has a new publication#// date to see if a new download is required (in case the dependency is#// a changing one)#cachedPublicationDate#=#rmr#.#getDescriptor#(#)#.#getResolvedPublicationDate#(#)#;#}#}#}#}#// now download module descriptor and parse it#report#=#download#(#originalMetadataArtifact#,#new#ArtifactResourceResolver#(#)#{#public#ResolvedResource#resolve#(#Artifact#artifact#)#{#return#mdRef#;#}#}#,#backupDownloader#,#new#CacheDownloadOptions#(#)#.#setListener#(#options#.#getListener#(#)#)#.#setForce#(#true#)#)#;#Message#.#verbose#(#"\t"#+#report#)#;#if#(#report#.#getDownloadStatus#(#)#==#DownloadStatus#.#FAILED#)#{#Message#.#warn#(#"problem while downloading module descriptor: "#+#mdRef#.#getResource#(#)#+#": "#+#report#.#getDownloadDetails#(#)#+#" ("#+#report#.#getDownloadTimeMillis#(#)#+#"ms)"#)#;#return#null#;#}#try#{#ModuleDescriptor#md#=#getStaledMd#(#parser#,#options#,#report#.#getLocalFile#(#)#)#;#if#(#md#==#null#)#{#throw#new#IllegalStateException#(#"module descriptor parser returned a null module descriptor, "#+#"which is not allowed. "#+#"parser="#+#parser#+#"; parser class="#+#parser#.#getClass#(#)#.#getName#(#)#+#"; module descriptor resource="#+#mdRef#.#getResource#(#)#)#;#}#Message#.#debug#(#"\t"#+#getName#(#)#+#": parsed downloaded md file for "#+#mrid#+#"; parsed="#+#md#.#getModuleRevisionId#(#)#)#;#// check if we should delete old artifacts#boolean#deleteOldArtifacts#=#false#;#if#(#cachedPublicationDate#!=#null#&&#!#cachedPublicationDate#.#equals#(#md#.#getResolvedPublicationDate#(#)#)#)#{#// artifacts have changed, they should be downloaded again#Message#.#verbose#(#mrid#+#" has changed: deleting old artifacts"#)#;#deleteOldArtifacts#=#true#;#}#if#(#deleteOldArtifacts#)#{#String#[#]#confs#=#md#.#getConfigurationsNames#(#)#;#for#(#int#i#=#0#;#i#<#confs#.#length#;#i#++#)#{#Artifact#[#]#arts#=#md#.#getArtifacts#(#confs#[#i#]#)#;#for#(#int#j#=#0#;#j#<#arts#.#length#;#j#++#)#{#Artifact#transformedArtifact#=#NameSpaceHelper#.#transform#(#arts#[#j#]#,#options#.#getNamespace#(#)#.#getToSystemTransformer#(#)#)#;#ArtifactOrigin#origin#=#getSavedArtifactOrigin#(#transformedArtifact#)#;#File#artFile#=#getArchiveFileInCache#(#transformedArtifact#,#origin#,#false#)#;#if#(#artFile#.#exists#(#)#)#{#Message#.#debug#(#"deleting "#+#artFile#)#;#if#(#!#artFile#.#delete#(#)#)#{#// Old artifacts couldn't get deleted!#// Restore the original ivy file so the next time we#// resolve the old artifacts are deleted again#backupDownloader#.#restore#(#)#;#Message#.#error#(#"Couldn't delete outdated artifact from cache: "#+#artFile#)#;#return#null#;#}#}#removeSavedArtifactOrigin#(#transformedArtifact#)#;#}#}#}#else#if#(#isChanging#(#dd#,#mrid#,#options#)#)#{#Message#.#verbose#(#mrid#+#" is changing, but has not changed: will trust cached artifacts if any"#)#;#}#MetadataArtifactDownloadReport#madr#=#new#MetadataArtifactDownloadReport#(#md#.#getMetadataArtifact#(#)#)#;#madr#.#setSearched#(#true#)#;#madr#.#setDownloadStatus#(#report#.#getDownloadStatus#(#)#)#;#madr#.#setDownloadDetails#(#report#.#getDownloadDetails#(#)#)#;#madr#.#setArtifactOrigin#(#report#.#getArtifactOrigin#(#)#)#;#madr#.#setDownloadTimeMillis#(#report#.#getDownloadTimeMillis#(#)#)#;#madr#.#setOriginalLocalFile#(#report#.#getLocalFile#(#)#)#;#madr#.#setSize#(#report#.#getSize#(#)#)#;#saveArtifactOrigin#(#md#.#getMetadataArtifact#(#)#,#report#.#getArtifactOrigin#(#)#)#;#return#new#ResolvedModuleRevision#(#resolver#,#resolver#,#md#,#madr#)#;#}#catch#(#IOException#ex#)#{#Message#.#warn#(#"io problem while parsing ivy file: "#+#mdRef#.#getResource#(#)#+#": "#+#ex#.#getMessage#(#)#)#;#return#null#;#}#}#finally#{#unlockMetadataArtifact#(#mrid#)#;#backupDownloader#.#cleanUp#(#)#;#}#}##ResolvedResource#resolve#(#Artifact#artifact#)#{#return#mdRef#;#}##boolean#lockMetadataArtifact#(#ModuleRevisionId#mrid#)#{#Artifact#artifact#=#getDefaultMetadataArtifact#(#mrid#)#;#try#{#// we need to provide an artifact origin to be sure we do not end up in a stack overflow#// if the cache pattern is using original name, and the substitution thus trying to get#// the saved artifact origin value which in turns calls this method#return#getLockStrategy#(#)#.#lockArtifact#(#artifact#,#getArchiveFileInCache#(#artifact#,#getDefaultMetadataArtifactOrigin#(#mrid#)#)#)#;#}#catch#(#InterruptedException#e#)#{#Thread#.#currentThread#(#)#.#interrupt#(#)#;#// reset interrupt status #throw#new#RuntimeException#(#"operation interrupted"#)#;#}#}##void#unlockMetadataArtifact#(#ModuleRevisionId#mrid#)#{#Artifact#artifact#=#getDefaultMetadataArtifact#(#mrid#)#;#getLockStrategy#(#)#.#unlockArtifact#(#artifact#,#getArchiveFileInCache#(#artifact#,#getDefaultMetadataArtifactOrigin#(#mrid#)#)#)#;#}##ArtifactOrigin#getDefaultMetadataArtifactOrigin#(#ModuleRevisionId#mrid#)#{#// it's important to say the origin is not local to make sure it won't ever be used for#// anything else than original token#return#new#ArtifactOrigin#(#DefaultArtifact#.#newIvyArtifact#(#mrid#,#null#)#,#false#,#getIvyFileInCache#(#mrid#)#.#getPath#(#)#)#;#}##Artifact#getDefaultMetadataArtifact#(#ModuleRevisionId#mrid#)#{#return#new#DefaultArtifact#(#mrid#,#new#Date#(#)#,#"metadata"#,#"metadata"#,#"ivy"#,#true#)#;#}##Artifact#getOriginalMetadataArtifact#(#Artifact#moduleArtifact#)#{#return#DefaultArtifact#.#cloneWithAnotherType#(#moduleArtifact#,#moduleArtifact#.#getType#(#)#+#".original"#)#;#}##boolean#isOriginalMetadataArtifact#(#Artifact#artifact#)#{#return#artifact#.#isMetadata#(#)#&&#artifact#.#getType#(#)#.#endsWith#(#".original"#)#;#}##boolean#isChanging#(#DependencyDescriptor#dd#,#ModuleRevisionId#requestedRevisionId#,#CacheMetadataOptions#options#)#{#return#dd#.#isChanging#(#)#||#getChangingMatcher#(#options#)#.#matches#(#requestedRevisionId#.#getRevision#(#)#)#;#}##Matcher#getChangingMatcher#(#CacheMetadataOptions#options#)#{#String#changingPattern#=#options#.#getChangingPattern#(#)#!=#null#?#options#.#getChangingPattern#(#)#:#this#.#changingPattern#;#if#(#changingPattern#==#null#)#{#return#NoMatcher#.#INSTANCE#;#}#String#changingMatcherName#=#options#.#getChangingMatcherName#(#)#!=#null#?#options#.#getChangingMatcherName#(#)#:#this#.#changingMatcherName#;#PatternMatcher#matcher#=#settings#.#getMatcher#(#changingMatcherName#)#;#if#(#matcher#==#null#)#{#throw#new#IllegalStateException#(#"unknown matcher '"#+#changingMatcherName#+#"'. It is set as changing matcher in "#+#this#)#;#}#return#matcher#.#getMatcher#(#changingPattern#)#;#}##boolean#isCheckmodified#(#DependencyDescriptor#dd#,#ModuleRevisionId#requestedRevisionId#,#CacheMetadataOptions#options#)#{#if#(#options#.#isCheckmodified#(#)#!=#null#)#{#return#options#.#isCheckmodified#(#)#.#booleanValue#(#)#;#}#return#isCheckmodified#(#)#;#}##void#clean#(#)#{#FileUtil#.#forceDelete#(#getBasedir#(#)#)#;#}##void#dumpSettings#(#)#{#Message#.#verbose#(#"\t"#+#getName#(#)#)#;#Message#.#debug#(#"\t\tivyPattern: "#+#getIvyPattern#(#)#)#;#Message#.#debug#(#"\t\tartifactPattern: "#+#getArtifactPattern#(#)#)#;#Message#.#debug#(#"\t\tlockingStrategy: "#+#getLockStrategy#(#)#.#getName#(#)#)#;#Message#.#debug#(#"\t\tchangingPattern: "#+#getChangingPattern#(#)#)#;#Message#.#debug#(#"\t\tchangingMatcher: "#+#getChangingMatcherName#(#)#)#;#}##void#download#(#Artifact#artifact#,#Resource#resource#,#File#dest#)#throws#IOException#{#// keep a copy of the original file#if#(#dest#.#exists#(#)#)#{#originalPath#=#dest#.#getAbsolutePath#(#)#;#backup#=#new#File#(#dest#.#getAbsolutePath#(#)#+#".backup"#)#;#FileUtil#.#copy#(#dest#,#backup#,#null#,#true#)#;#}#delegate#.#download#(#artifact#,#resource#,#dest#)#;#}##void#restore#(#)#throws#IOException#{#if#(#(#backup#!=#null#)#&&#backup#.#exists#(#)#)#{#File#original#=#new#File#(#originalPath#)#;#FileUtil#.#copy#(#backup#,#original#,#null#,#true#)#;#backup#.#delete#(#)#;#}#}##void#cleanUp#(#)#{#if#(#(#backup#!=#null#)#&&#backup#.#exists#(#)#)#{#backup#.#delete#(#)#;#}#}##