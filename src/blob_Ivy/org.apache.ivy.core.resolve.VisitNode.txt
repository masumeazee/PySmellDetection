IvyNode#getNode#(#)#{#return#node#;#}##String#getRequestedConf#(#)#{#return#requestedConf#;#}##void#setRequestedConf#(#String#requestedConf#)#{#this#.#requestedConf#=#requestedConf#;#}##VisitNode#getParent#(#)#{#return#parent#;#}##VisitNode#getRoot#(#)#{#if#(#root#==#null#)#{#root#=#computeRoot#(#)#;#}#return#root#;#}##Collection#/*<VisitNode>*/#getPath#(#)#{#if#(#path#==#null#)#{#path#=#computePath#(#)#;#}#return#path#;#}##Collection#/*<VisitNode>*/#computePath#(#)#{#if#(#parent#!=#null#)#{#Collection#p#=#new#LinkedHashSet#(#parent#.#getPath#(#)#)#;#p#.#add#(#this#)#;#return#p#;#}#else#{#return#Collections#.#singletonList#(#this#)#;#}#}##VisitNode#computeRoot#(#)#{#if#(#node#.#isRoot#(#)#)#{#return#this#;#}#else#if#(#parent#!=#null#)#{#return#parent#.#getRoot#(#)#;#}#else#{#return#null#;#}#}##String#getParentConf#(#)#{#return#parentConf#;#}##void#setParentConf#(#String#parentConf#)#{#this#.#parentConf#=#parentConf#;#}##String#getRootModuleConf#(#)#{#return#rootModuleConf#;#}##VisitNode#getRoot#(#VisitNode#parent#)#{#VisitNode#root#=#parent#;#Collection#path#=#new#HashSet#(#)#;#path#.#add#(#root#)#;#while#(#root#.#getParent#(#)#!=#null#&&#!#root#.#getNode#(#)#.#isRoot#(#)#)#{#if#(#path#.#contains#(#root#.#getParent#(#)#)#)#{#return#root#;#}#root#=#root#.#getParent#(#)#;#path#.#add#(#root#)#;#}#return#root#;#}##boolean#isTransitive#(#)#{#return#(#data#.#isTransitive#(#)#&&#(#node#.#getDependencyDescriptor#(#getParentNode#(#)#)#.#isTransitive#(#)#||#node#.#hasAnyMergedUsageWithTransitiveDependency#(#rootModuleConf#)#)#&&#isParentConfTransitive#(#)#)#;#}##boolean#isParentConfTransitive#(#)#{#String#conf#=#getParent#(#)#.#getRequestedConf#(#)#;#if#(#conf#==#null#)#{#return#true#;#}#Configuration#parentConf#=#getParentNode#(#)#.#getConfiguration#(#conf#)#;#return#parentConf#.#isTransitive#(#)#;#}##IvyNode#getRealNode#(#)#{#IvyNode#node#=#this#.#node#.#getRealNode#(#)#;#if#(#node#!=#null#)#{#return#node#;#}#else#{#return#this#.#node#;#}#}##void#useRealNode#(#)#{#if#(#parent#!=#null#)#{#// use real node make sense only for non root module#IvyNode#node#=#data#.#getNode#(#this#.#node#.#getId#(#)#)#;#if#(#node#!=#null#&&#node#!=#this#.#node#)#{#this#.#node#=#node#;#}#}#}##boolean#loadData#(#String#conf#,#boolean#shouldBePublic#)#{#boolean#loaded#=#node#.#loadData#(#rootModuleConf#,#getParentNode#(#)#,#parentConf#,#conf#,#shouldBePublic#,#getUsage#(#)#)#;#if#(#loaded#)#{#useRealNode#(#)#;#// check if the real node is blacklisted -> if so, skip further loading#if#(#getRealNode#(#)#.#isBlacklisted#(#rootModuleConf#)#)#{#Message#.#debug#(#rootModuleConf#+#" is blacklisted. Skip loading"#)#;#return#false#;#}#// if the loaded revision is different from original one#// we now register this node on the new resolved id#// this includes two cases:#// - the id refers to a dynamic revision, which has been resolved by loadData#// - the loaded module descriptor has extra attributes in his info tag which are not #//   used when declaring the dependency#if#(#data#.#getNode#(#node#.#getResolvedId#(#)#)#==#null#||#!#data#.#getNode#(#node#.#getResolvedId#(#)#)#.#getId#(#)#.#equals#(#node#.#getResolvedId#(#)#)#)#{#data#.#register#(#node#.#getResolvedId#(#)#,#this#)#;#}#}#return#loaded#;#}##Collection#getDependencies#(#String#conf#)#{#Collection#deps#=#node#.#getDependencies#(#rootModuleConf#,#conf#,#requestedConf#)#;#Collection#ret#=#new#ArrayList#(#deps#.#size#(#)#)#;#for#(#Iterator#iter#=#deps#.#iterator#(#)#;#iter#.#hasNext#(#)#;#)#{#IvyNode#depNode#=#(#IvyNode#)#iter#.#next#(#)#;#ret#.#add#(#traverseChild#(#conf#,#depNode#)#)#;#}#return#ret#;#}##VisitNode#gotoNode#(#IvyNode#node#)#{#if#(#!#getModuleId#(#)#.#equals#(#node#.#getModuleId#(#)#)#)#{#throw#new#IllegalArgumentException#(#"You can't use gotoNode for a node which does not represent the same Module "#+#"as the one represented by this node.\nCurrent node module id="#+#getModuleId#(#)#+#" Given node module id="#+#node#.#getModuleId#(#)#)#;#}#VisitData#visitData#=#data#.#getVisitData#(#node#.#getId#(#)#)#;#if#(#visitData#!=#null#)#{#List#visitNodes#=#visitData#.#getVisitNodes#(#rootModuleConf#)#;#for#(#Iterator#iter#=#visitNodes#.#iterator#(#)#;#iter#.#hasNext#(#)#;#)#{#VisitNode#vnode#=#(#VisitNode#)#iter#.#next#(#)#;#if#(#(#parent#==#null#&&#vnode#.#getParent#(#)#==#null#)#||#(#parent#!=#null#&&#parent#.#getId#(#)#.#equals#(#vnode#.#getParent#(#)#.#getId#(#)#)#)#)#{#vnode#.#parentConf#=#parentConf#;#vnode#.#usage#=#getUsage#(#)#;#return#vnode#;#}#}#}#// the node has not yet been visited from the current parent, we create a new visit node#return#traverse#(#parent#,#parentConf#,#node#,#getUsage#(#)#)#;#}##IvyNodeUsage#getUsage#(#)#{#return#usage#==#null#?#node#.#getMainUsage#(#)#:#usage#;#}##VisitNode#traverseChild#(#String#parentConf#,#IvyNode#child#)#{#VisitNode#parent#=#this#;#return#traverse#(#parent#,#parentConf#,#child#,#null#)#;#}##VisitNode#traverse#(#VisitNode#parent#,#String#parentConf#,#IvyNode#node#,#IvyNodeUsage#usage#)#{#if#(#getPath#(#)#.#contains#(#node#)#)#{#IvyContext#.#getContext#(#)#.#getCircularDependencyStrategy#(#)#.#handleCircularDependency#(#toMrids#(#getPath#(#)#,#node#.#getId#(#)#)#)#;#// we do not use the new parent, but the first one, to always be able to go up to the#// root#// parent = getVisitNode(depNode).getParent();#}#return#new#VisitNode#(#data#,#node#,#parent#,#rootModuleConf#,#parentConf#,#usage#)#;#}##ModuleRevisionId#[#]#toMrids#(#Collection#path#,#ModuleRevisionId#last#)#{#ModuleRevisionId#[#]#ret#=#new#ModuleRevisionId#[#path#.#size#(#)#+#1#]#;#int#i#=#0#;#for#(#Iterator#iter#=#path#.#iterator#(#)#;#iter#.#hasNext#(#)#;#i#++#)#{#VisitNode#node#=#(#VisitNode#)#iter#.#next#(#)#;#ret#[#i#]#=#node#.#getNode#(#)#.#getId#(#)#;#}#ret#[#ret#.#length#-#1#]#=#last#;#return#ret#;#}##ModuleRevisionId#getResolvedId#(#)#{#return#node#.#getResolvedId#(#)#;#}##void#updateConfsToFetch#(#Collection#confs#)#{#node#.#updateConfsToFetch#(#confs#)#;#}##ModuleRevisionId#getId#(#)#{#return#node#.#getId#(#)#;#}##boolean#isEvicted#(#)#{#return#node#.#isEvicted#(#rootModuleConf#)#;#}##String#[#]#getRealConfs#(#String#conf#)#{#return#node#.#getRealConfs#(#conf#)#;#}##boolean#hasProblem#(#)#{#return#node#.#hasProblem#(#)#;#}##Configuration#getConfiguration#(#String#conf#)#{#return#node#.#getConfiguration#(#conf#)#;#}##EvictionData#getEvictedData#(#)#{#return#node#.#getEvictedData#(#rootModuleConf#)#;#}##DependencyDescriptor#getDependencyDescriptor#(#)#{#return#node#.#getDependencyDescriptor#(#getParentNode#(#)#)#;#}##IvyNode#getParentNode#(#)#{#return#parent#==#null#?#null#:#parent#.#getNode#(#)#;#}##boolean#isCircular#(#)#{#if#(#isCircular#==#null#)#{#if#(#parent#!=#null#)#{#isCircular#=#Boolean#.#FALSE#;#// asumme it's false, and see if it isn't by checking#// the parent path#for#(#Iterator#iter#=#parent#.#getPath#(#)#.#iterator#(#)#;#iter#.#hasNext#(#)#;#)#{#VisitNode#ancestor#=#(#VisitNode#)#iter#.#next#(#)#;#if#(#getId#(#)#.#getModuleId#(#)#.#equals#(#ancestor#.#getId#(#)#.#getModuleId#(#)#)#)#{#isCircular#=#Boolean#.#TRUE#;#break#;#}#}#}#else#{#isCircular#=#Boolean#.#FALSE#;#}#}#return#isCircular#.#booleanValue#(#)#;#}##String#[#]#getConfsToFetch#(#)#{#return#node#.#getConfsToFetch#(#)#;#}##String#[#]#getRequiredConfigurations#(#VisitNode#in#,#String#inConf#)#{#return#node#.#getRequiredConfigurations#(#in#.#getNode#(#)#,#inConf#)#;#}##ModuleId#getModuleId#(#)#{#return#node#.#getModuleId#(#)#;#}##Collection#getResolvedRevisions#(#ModuleId#mid#)#{#return#node#.#getResolvedRevisions#(#mid#,#rootModuleConf#)#;#}##void#markEvicted#(#EvictionData#evictionData#)#{#node#.#markEvicted#(#evictionData#)#;#}##String#[#]#getRequiredConfigurations#(#)#{#return#node#.#getRequiredConfigurations#(#)#;#}##void#markEvicted#(#VisitNode#parent#,#ConflictManager#conflictMgr#,#Collection#selected#)#{#node#.#markEvicted#(#rootModuleConf#,#parent#.#getNode#(#)#,#conflictMgr#,#selected#)#;#}##ModuleDescriptor#getDescriptor#(#)#{#return#node#.#getDescriptor#(#)#;#}##EvictionData#getEvictionDataInRoot#(#String#rootModuleConf#,#VisitNode#ancestor#)#{#return#node#.#getEvictionDataInRoot#(#rootModuleConf#,#ancestor#.#getNode#(#)#)#;#}##Collection#getEvictedRevisions#(#ModuleId#moduleId#)#{#return#node#.#getEvictedRevisions#(#moduleId#,#rootModuleConf#)#;#}##String#toString#(#)#{#return#node#.#toString#(#)#;#}##boolean#isConfRequiredByMergedUsageOnly#(#String#conf#)#{#return#node#.#isConfRequiredByMergedUsageOnly#(#rootModuleConf#,#conf#)#;#}##