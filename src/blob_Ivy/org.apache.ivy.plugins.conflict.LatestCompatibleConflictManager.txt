Collection#resolveConflicts#(#IvyNode#parent#,#Collection#conflicts#)#{#if#(#conflicts#.#size#(#)#<#2#)#{#return#conflicts#;#}#VersionMatcher#versionMatcher#=#getSettings#(#)#.#getVersionMatcher#(#)#;#Iterator#iter#=#conflicts#.#iterator#(#)#;#IvyNode#node#=#(#IvyNode#)#iter#.#next#(#)#;#ModuleRevisionId#mrid#=#node#.#getResolvedId#(#)#;#if#(#versionMatcher#.#isDynamic#(#mrid#)#)#{#while#(#iter#.#hasNext#(#)#)#{#IvyNode#other#=#(#IvyNode#)#iter#.#next#(#)#;#if#(#versionMatcher#.#isDynamic#(#other#.#getResolvedId#(#)#)#)#{#// two dynamic versions in conflict, not enough information yet#return#null#;#}#else#if#(#!#versionMatcher#.#accept#(#mrid#,#other#.#getResolvedId#(#)#)#)#{#// incompatibility found#if#(#!#handleIncompatibleConflict#(#parent#,#conflicts#,#node#,#other#)#)#{#return#null#;#}#}#}#// no incompatibility nor dynamic version found, let's return the latest static version#if#(#conflicts#.#size#(#)#==#2#)#{#// very common special case of only two modules in conflict, #// let's return the second one (static)#Iterator#it#=#conflicts#.#iterator#(#)#;#it#.#next#(#)#;#return#Collections#.#singleton#(#it#.#next#(#)#)#;#}#Collection#newConflicts#=#new#LinkedHashSet#(#conflicts#)#;#newConflicts#.#remove#(#node#)#;#return#super#.#resolveConflicts#(#parent#,#newConflicts#)#;#}#else#{#// the first node is a static revision, let's see if all other versions match#while#(#iter#.#hasNext#(#)#)#{#IvyNode#other#=#(#IvyNode#)#iter#.#next#(#)#;#if#(#!#versionMatcher#.#accept#(#other#.#getResolvedId#(#)#,#mrid#)#)#{#// incompatibility found#if#(#!#handleIncompatibleConflict#(#parent#,#conflicts#,#node#,#other#)#)#{#return#null#;#}#}#}#// no incompatibility found, let's return this static version#return#Collections#.#singleton#(#node#)#;#}#}##boolean#handleIncompatibleConflict#(#IvyNode#parent#,#Collection#conflicts#,#IvyNode#node#,#IvyNode#other#)#{#// we never actually return anything else than false or throw an exception, #// but returning a boolean make the calling code cleaner#try#{#IvyNodeArtifactInfo#latest#=#(#IvyNodeArtifactInfo#)#getStrategy#(#)#.#findLatest#(#toArtifactInfo#(#Arrays#.#asList#(#new#IvyNode#[#]#{#node#,#other#}#)#)#,#null#)#;#if#(#latest#!=#null#)#{#IvyNode#latestNode#=#latest#.#getNode#(#)#;#IvyNode#oldestNode#=#latestNode#==#node#?#other#:#node#;#blackListIncompatibleCallerAndRestartResolveIfPossible#(#getSettings#(#)#,#parent#,#oldestNode#,#latestNode#)#;#// if we arrive here, we haven' managed to blacklist all paths to the latest#// node, we try with the oldest#blackListIncompatibleCallerAndRestartResolveIfPossible#(#getSettings#(#)#,#parent#,#latestNode#,#oldestNode#)#;#// still not possible, we aren't able to find a solution to the incompatibility#handleUnsolvableConflict#(#parent#,#conflicts#,#node#,#other#)#;#return#true#;#// never actually reached#}#else#{#return#false#;#}#}#catch#(#NoConflictResolvedYetException#ex#)#{#// we have not enough informations in the nodes to resolve conflict#// according to the resolveConflicts contract, resolveConflicts must return null#return#false#;#}#}##void#blackListIncompatibleCallerAndRestartResolveIfPossible#(#IvySettings#settings#,#IvyNode#parent#,#IvyNode#selected#,#IvyNode#evicted#)#{#Stack#callerStack#=#new#Stack#(#)#;#callerStack#.#push#(#evicted#)#;#final#Collection#toBlacklist#=#blackListIncompatibleCaller#(#settings#.#getVersionMatcher#(#)#,#parent#,#selected#,#evicted#,#callerStack#)#;#if#(#toBlacklist#!=#null#)#{#final#StringBuffer#blacklisted#=#new#StringBuffer#(#)#;#for#(#Iterator#iterator#=#toBlacklist#.#iterator#(#)#;#iterator#.#hasNext#(#)#;#)#{#IvyNodeBlacklist#blacklist#=#(#IvyNodeBlacklist#)#iterator#.#next#(#)#;#blacklist#.#getBlacklistedNode#(#)#.#blacklist#(#blacklist#)#;#blacklisted#.#append#(#blacklist#.#getBlacklistedNode#(#)#)#;#if#(#iterator#.#hasNext#(#)#)#{#blacklisted#.#append#(#" "#)#;#}#}#String#rootModuleConf#=#parent#.#getData#(#)#.#getReport#(#)#.#getConfiguration#(#)#;#evicted#.#markEvicted#(#new#EvictionData#(#rootModuleConf#,#parent#,#this#,#Collections#.#singleton#(#selected#)#,#"with blacklisting of "#+#blacklisted#)#)#;#if#(#settings#.#debugConflictResolution#(#)#)#{#Message#.#debug#(#"evicting "#+#evicted#+#" by "#+#evicted#.#getEvictedData#(#rootModuleConf#)#)#;#}#throw#new#RestartResolveProcess#(#"trying to handle incompatibilities between "#+#selected#+#" and "#+#evicted#)#;#}#}##Collection#/*<IvyNodeBlacklist>*/#blackListIncompatibleCaller#(#VersionMatcher#versionMatcher#,#IvyNode#conflictParent#,#IvyNode#selectedNode#,#IvyNode#evictedNode#,#Stack#/*<IvyNode>*/#callerStack#)#{#Collection#/*<IvyNodeBlacklist>*/#blacklisted#=#new#ArrayList#/*<IvyNodeBlacklist>*/#(#)#;#IvyNode#node#=#(#IvyNode#)#callerStack#.#peek#(#)#;#String#rootModuleConf#=#conflictParent#.#getData#(#)#.#getReport#(#)#.#getConfiguration#(#)#;#Caller#[#]#callers#=#node#.#getCallers#(#rootModuleConf#)#;#for#(#int#i#=#0#;#i#<#callers#.#length#;#i#++#)#{#IvyNode#callerNode#=#node#.#findNode#(#callers#[#i#]#.#getModuleRevisionId#(#)#)#;#if#(#callerNode#.#isBlacklisted#(#rootModuleConf#)#)#{#continue#;#}#if#(#versionMatcher#.#isDynamic#(#callers#[#i#]#.#getAskedDependencyId#(#node#.#getData#(#)#)#)#)#{#blacklisted#.#add#(#new#IvyNodeBlacklist#(#conflictParent#,#selectedNode#,#evictedNode#,#node#,#rootModuleConf#)#)#;#}#else#{#if#(#callerStack#.#subList#(#0#,#callerStack#.#size#(#)#-#1#)#.#contains#(#node#)#)#{#// circular dependency found and handled: the current top of the stack (node)#// was already contained in the rest of the stack, the circle is closed, nothing#// else to do#}#else#{#if#(#callerNode#==#null#)#{#// we have reached the root without finding a way to change the blacklist a#// caller in a particular path, this is a strict conflict#return#null#;#}#callerStack#.#push#(#callerNode#)#;#Collection#sub#=#blackListIncompatibleCaller#(#versionMatcher#,#conflictParent#,#selectedNode#,#evictedNode#,#callerStack#)#;#callerStack#.#pop#(#)#;#if#(#sub#==#null#)#{#// propagate the fact that a path with unblacklistable caller has been found#return#null#;#}#else#{#blacklisted#.#addAll#(#sub#)#;#}#}#}#}#if#(#blacklisted#.#isEmpty#(#)#&&#!#callerStack#.#subList#(#0#,#callerStack#.#size#(#)#-#1#)#.#contains#(#node#)#)#{#return#null#;#}#return#blacklisted#;#}##void#handleUnsolvableConflict#(#IvyNode#parent#,#Collection#conflicts#,#IvyNode#node1#,#IvyNode#node2#)#{#throw#new#StrictConflictException#(#node1#,#node2#)#;#}##void#handleAllBlacklistedRevisions#(#DependencyDescriptor#dd#,#Collection#/*<ModuleRevisionId>*/#foundBlacklisted#)#{#ResolveData#resolveData#=#IvyContext#.#getContext#(#)#.#getResolveData#(#)#;#Collection#/*<IvyNode>*/#blacklisted#=#new#HashSet#(#)#;#for#(#Iterator#iterator#=#foundBlacklisted#.#iterator#(#)#;#iterator#.#hasNext#(#)#;#)#{#ModuleRevisionId#mrid#=#(#ModuleRevisionId#)#iterator#.#next#(#)#;#blacklisted#.#add#(#resolveData#.#getNode#(#mrid#)#)#;#}#for#(#Iterator#iterator#=#blacklisted#.#iterator#(#)#;#iterator#.#hasNext#(#)#;#)#{#IvyNode#node#=#(#IvyNode#)#iterator#.#next#(#)#;#IvyNodeBlacklist#bdata#=#node#.#getBlacklistData#(#resolveData#.#getReport#(#)#.#getConfiguration#(#)#)#;#handleUnsolvableConflict#(#bdata#.#getConflictParent#(#)#,#Arrays#.#asList#(#new#Object#[#]#{#bdata#.#getEvictedNode#(#)#,#bdata#.#getSelectedNode#(#)#}#)#,#bdata#.#getEvictedNode#(#)#,#bdata#.#getSelectedNode#(#)#)#;#}#}##String#toString#(#)#{#return#getName#(#)#;#}##